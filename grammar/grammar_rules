start:translation_unit
translation_unit:external_declaration {MakeAbstractSyntaxTree(&$$); $$->info = NULL; *SetAbstractSyntaxTreeNodeChild($$) = $0;}
translation_unit:translation_unit external_declaration {$$ = $0; *SetAbstractSyntaxTreeNodeChild($0) = $1; }
external_declaration:function_definition
external_declaration:declaration
function_definition:declaration_specifiers direct_declarator LEFT_PAREN parameter_list RIGHT_PAREN compound_statement {MakeAbstractSyntaxTree(&$$); $$->info = $1->info; ((Symbol*)$1->info)->type = ((Token*)$0->info)->type; *SetAbstractSyntaxTreeNodeChild($$) = $3; *SetAbstractSyntaxTreeNodeChild($$) = $5;}
function_definition:declaration_specifiers direct_declarator LEFT_PAREN RIGHT_PAREN compound_statement {MakeAbstractSyntaxTree(&$$); $$->info = $1->info; ((Symbol*)$1->info)->type = ((Token*)$0->info)->type; *SetAbstractSyntaxTreeNodeChild($$) = $4;}
function_definition:direct_declarator declaration_list compound_statement
function_definition:direct_declarator compound_statement
jump_statement:RETURN SEMI_COLON
jump_statement:RETURN expression SEMI_COLON
iteration_statement:WHILE LEFT_PAREN expression RIGHT_PAREN statement
iteration_statement:FOR LEFT_PAREN declaration expression_statement expression RIGHT_PAREN statement
iteration_statement:FOR LEFT_PAREN expression_statement expression_statement expression RIGHT_PAREN statement
selection_statement:IF LEFT_PAREN expression RIGHT_PAREN statement
expression_statement:SEMI_COLON
expression_statement:expression SEMI_COLON {$$ = $0;}
statement_list:statement
statement_list:statement_list statement
declaration_list:declaration {MakeAbstractSyntaxTree(&$$); $$->info = NULL; *SetAbstractSyntaxTreeNodeChild($$) = $0;}
declaration_list:declaration_list declaration {$$ = $0; *SetAbstractSyntaxTreeNodeChild($0) = $1; }
compound_statement:LEFT_CURLY RIGHT_CURLY
compound_statement:block_enter statement_list RIGHT_CURLY {ExitScope(scopeStack); $$ = $1;}
compound_statement:block_enter declaration_list RIGHT_CURLY {ExitScope(scopeStack); $$ = $1;}
compound_statement:block_enter declaration_list statement_list RIGHT_CURLY {ExitScope(scopeStack); $$ = $1;}
block_enter:LEFT_CURLY {EnterScope(scopeStack); $$ = $0;}
statement:compound_statement
statement:expression_statement
statement:selection_statement
statement:iteration_statement
statement:jump_statement
initializer_list:initializer
initializer_list:initializer_list COMMA initializer
initializer:assignment_expression
initializer:LEFT_CURLY initializer_list RIGHT_CURLY
initializer:LEFT_CURLY initializer_list COMMA RIGHT_CURLY
direct_abstract_declarator:LEFT_PAREN abstract_declarator RIGHT_PAREN
direct_abstract_declarator:LEFT_BRACKET RIGHT_BRACKET
direct_abstract_declarator:LEFT_BRACKET constant_expression RIGHT_BRACKET
direct_abstract_declarator:direct_abstract_declarator LEFT_BRACKET constant_expression RIGHT_BRACKET
direct_abstract_declarator:direct_abstract_declarator LEFT_BRACKET RIGHT_BRACKET
direct_abstract_declarator:LEFT_PAREN RIGHT_PAREN
direct_abstract_declarator:LEFT_PAREN parameter_type_list RIGHT_PAREN
direct_abstract_declarator:direct_abstract_declarator LEFT_PAREN RIGHT_PAREN
direct_abstract_declarator:direct_abstract_declarator LEFT_PAREN parameter_type_list RIGHT_PAREN
abstract_declarator:pointer
abstract_declarator:direct_abstract_declarator
abstract_declarator:pointer direct_abstract_declarator
type_name:specifier_qualifier_list
type_name:specifier_qualifier_list abstract_declarator
identifier_list:IDENTIFIER
identifier_list:identifier_list COMMA IDENTIFIER
parameter_declaration:declaration_specifiers declarator {MakeAbstractSyntaxTree(&$$); $$->info = $1->info; ((Symbol*)$1->info)->type = ((Token*)$0->info)->type; InsertSymbol(scopeStack, $1->info);}
parameter_declaration:declaration_specifiers abstract_declarator
parameter_declaration:declaration_specifiers
parameter_list:parameter_declaration
parameter_list:parameter_list COMMA parameter_declaration
parameter_type_list:parameter_list
pointer:STAR
pointer:STAR pointer
direct_declarator:IDENTIFIER {Symbol* symbol; MakeSymbol(&symbol); symbol->name = ((Token*)$0->info)->lexeme; $0->info = symbol; $$ = $0;}
direct_declarator:LEFT_BRACKET constant_expression RIGHT_BRACKET
direct_declarator:LEFT_BRACKET RIGHT_BRACKET
direct_declarator:LEFT_PAREN parameter_type_list RIGHT_PAREN
direct_declarator:LEFT_PAREN identifier_list RIGHT_PAREN
declarator:pointer direct_declarator
declarator:direct_declarator
enumerator:IDENTIFIER
enumerator:IDENTIFIER EQ constant_expression
enumerator_list:enumerator
enumerator_list:enumerator_list COMMA enumerator
struct_declarator:declarator
struct_declarator_list:struct_declarator
struct_declarator_list:struct_declarator_list COMMA struct_declarator
specifier_qualifier_list:type_specifier specifier_qualifier_list
specifier_qualifier_list:type_specifier
struct_declaration:specifier_qualifier_list struct_declarator_list SEMI_COLON
struct_declaration_list:struct_declaration
struct_declaration_list:struct_declaration_list struct_declaration
struct_or_union_specifier:STRUCT IDENTIFIER LEFT_CURLY struct_declaration_list RIGHT_CURLY
struct_or_union_specifier:STRUCT LEFT_CURLY struct_declaration_list RIGHT_CURLY
struct_or_union_specifier:STRUCT IDENTIFIER
type_specifier:VOID
type_specifier:CHAR
type_specifier:SHORT
type_specifier:INT
type_specifier:LONG
type_specifier:FLOAT
type_specifier:DOUBLE
type_specifier:UNSIGNED
type_specifier:struct_or_union_specifier
init_declarator:declarator
init_declarator:declarator EQ initializer
init_declarator_list:init_declarator
init_declarator_list:init_declarator_list COMMA init_declarator
declaration_specifiers:type_specifier
declaration_specifiers:type_specifier declaration_specifiers
declaration:declaration_specifiers SEMI_COLON
declaration:declaration_specifiers init_declarator_list SEMI_COLON {$$ = $1; ((Symbol*)$1->info)->type = ((Token*)$0->info)->type; if (!LookupSymbol(scopeStack, ((Symbol*)$1->info)->name)) InsertSymbol(scopeStack, $1->info); else printf("%s has already been defined.", ((Symbol*)$1->info)->name);}
constant_expression:conditional_expression
expression:assignment_expression
expression:expression COMMA assignment_expression
assignment_operator:EQ
assignment_operator:STAR EQ
assignment_operator:SLASH EQ
assignment_operator:MOD EQ
assignment_operator:PLUS EQ
assignment_operator:MINUS EQ
assignment_expression:conditional_expression
assignment_expression:unary_expression assignment_operator assignment_expression
conditional_expression:equality_expression
equality_expression:relational_expression
equality_expression:equality_expression EEQ relational_expression
equality_expression:equality_expression NEQ relational_expression
relational_expression:shift_expression
relational_expression:relational_expression GT shift_expression
relational_expression:relational_expression LT shift_expression
relational_expression:relational_expression GE shift_expression
relational_expression:relational_expression LE shift_expression
shift_expression:additive_expression
additive_expression:multiplicative_expression
additive_expression:additive_expression PLUS multiplicative_expression
additive_expression:additive_expression MINUS multiplicative_expression
multiplicative_expression:cast_expression
multiplicative_expression:multiplicative_expression STAR cast_expression
multiplicative_expression:multiplicative_expression SLASH cast_expression
multiplicative_expression:multiplicative_expression MOD cast_expression
cast_expression:unary_expression
cast_expression:LEFT_PAREN type_name RIGHT_PAREN cast_expression
unary_operator:STAR
unary_operator:PLUS
unary_operator:MINUS
unary_operator:AMPERSAND
unary_expression:postfix_expression
unary_expression:PLUS PLUS postfix_expression
unary_expression:MINUS MINUS postfix_expression
unary_expression:unary_operator cast_expression
argument_expression_list:assignment_expression
argument_expression_list:argument_expression_list COMMA assignment_expression
postfix_expression:primary_expression
postfix_expression:postfix_expression LEFT_BRACKET expression RIGHT_BRACKET
postfix_expression:postfix_expression LEFT_PAREN RIGHT_PAREN
postfix_expression:postfix_expression LEFT_PAREN argument_expression_list RIGHT_PAREN {$$ = $0; *SetAbstractSyntaxTreeNodeChild($0) = $2;}
postfix_expression:postfix_expression DOT IDENTIFIER
postfix_expression:postfix_expression ARROW IDENTIFIER
postfix_expression:postfix_expression PLUS PLUS
postfix_expression:postfix_expression MINUS MINUS
primary_expression:IDENTIFIER
primary_expression:INTEGER_LITERAL
primary_expression:FLOAT_LITERAL
primary_expression:STRING_LITERAL
primary_expression:LEFT_PAREN expression RIGHT_PAREN