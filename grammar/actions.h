#define _ACTIONS

AbstractSyntaxTreeNode *DefaultSemanticAction(void *scopeStack, Stack *semanticStack);
void AssignActions(Grammar *g);

void GenerateArithmeticExpression(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateAddition(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateSubtraction(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateIntegerLiteral(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateFloatLiteral(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateStringLiteral(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateAssignment(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateMult(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateDivision(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateDeclaration(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateSymbol(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateAdditionAssignment(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateReturn(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateIf(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateFor(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateIncrement(void *codeGenerator, AbstractSyntaxTreeNode *astNode);
void GenerateStatements(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateExpression(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateCall(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateReference(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateDereference(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateLT(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateGT(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateGE(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateLE(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateEEQ(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateNEQ(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateLSHIFT(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateRSHIFT(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateMod(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateAnd(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateNeg(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateIndexing(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateLogNot(void *generator, AbstractSyntaxTreeNode *astRoot);
void GenerateStructAccess(void *generator, AbstractSyntaxTreeNode *astRoot);

void AnalyzeAddition(AbstractSyntaxTreeNode *astNode);
void AnalyzeStructAccess(AbstractSyntaxTreeNode *astNode);

// void AnalyzeSubtraction(AbstractSyntaxTreeNode *astNode);
// void AnalyzeIntegerLiteral(AbstractSyntaxTreeNode *astNode);
// void AnalyzeFloatLiteral(AbstractSyntaxTreeNode *astNode);
// void AnalyzeStringLiteral(AbstractSyntaxTreeNode *astNode);
// void AnalyzeAssignment(AbstractSyntaxTreeNode *astNode);
// void AnalyzeMult(AbstractSyntaxTreeNode *astNode);
// void AnalyzeDivision(AbstractSyntaxTreeNode *astNode);
// void AnalyzeDeclaration(AbstractSyntaxTreeNode *astNode);
// void AnalyzeSymbol(AbstractSyntaxTreeNode *astNode);
// void AnalyzeAdditionAssignment(AbstractSyntaxTreeNode *astNode);
// void AnalyzeReturn(AbstractSyntaxTreeNode *astNode);
// void AnalyzeIf(AbstractSyntaxTreeNode *astNode);
// void AnalyzeIncrement(AbstractSyntaxTreeNode *astNode);
// void AnalyzeStatements(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeExpression(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeCall(AbstractSyntaxTreeNode *astRoot);
void AnalyzeReference(AbstractSyntaxTreeNode *astRoot);
void AnalyzeDereference(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeLT(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeGT(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeGE(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeLE(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeEEQ(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeNEQ(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeLSHIFT(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeRSHIFT(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeMod(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeAnd(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeNeg(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeIndexing(AbstractSyntaxTreeNode *astRoot);
// void AnalyzeLogNot(AbstractSyntaxTreeNode *astRoot);