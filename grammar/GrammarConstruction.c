AbstractSyntaxTreeNode* DefaultSemanticAction(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_1(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = NULL; *SetAbstractSyntaxTreeNodeChild(result) = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_2(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$0; *SetAbstractSyntaxTreeNodeChild(_$0) = _$1; 
return result;
}
            AbstractSyntaxTreeNode* semantic_5(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$5 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$4 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$3 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = _$1->info; ((Symbol*)_$1->info)->type = ((Token*)_$0->info)->type; *SetAbstractSyntaxTreeNodeChild(result) = _$3; *SetAbstractSyntaxTreeNodeChild(result) = _$5;
return result;
}
            AbstractSyntaxTreeNode* semantic_6(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$4 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$3 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = _$1->info; ((Symbol*)_$1->info)->type = ((Token*)_$0->info)->type; *SetAbstractSyntaxTreeNodeChild(result) = _$4;
return result;
}
            AbstractSyntaxTreeNode* semantic_11(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$4 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$3 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = NULL; *SetAbstractSyntaxTreeNodeChild(result) = _$2; *SetAbstractSyntaxTreeNodeChild(result) = _$4;
return result;
}
            AbstractSyntaxTreeNode* semantic_16(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_17(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = NULL; *SetAbstractSyntaxTreeNodeChild(result) = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_18(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$0; *SetAbstractSyntaxTreeNodeChild(_$0) = _$1;
return result;
}
            AbstractSyntaxTreeNode* semantic_19(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = NULL; *SetAbstractSyntaxTreeNodeChild(result) = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_20(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$0; *SetAbstractSyntaxTreeNodeChild(_$0) = _$1;
return result;
}
            AbstractSyntaxTreeNode* semantic_22(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
ExitScope(scopeStack); result = _$1;
return result;
}
            AbstractSyntaxTreeNode* semantic_23(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
ExitScope(scopeStack); result = _$1;
return result;
}
            AbstractSyntaxTreeNode* semantic_24(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$3 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
ExitScope(scopeStack); MakeAbstractSyntaxTree(&result); result->info = NULL; *SetAbstractSyntaxTreeNodeChild(result) = _$1; *SetAbstractSyntaxTreeNodeChild(result) = _$2;
return result;
}
            AbstractSyntaxTreeNode* semantic_25(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
EnterScope(scopeStack); result = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_52(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = _$1->info; ((Symbol*)_$1->info)->type = ((Token*)_$0->info)->type; InsertSymbol(scopeStack, _$1->info);
return result;
}
            AbstractSyntaxTreeNode* semantic_60(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
Symbol* symbol; MakeSymbol(&symbol); symbol->name = ((Token*)_$0->info)->lexeme; _$0->info = symbol; result = _$0;
return result;
}
            AbstractSyntaxTreeNode* semantic_98(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$1; ((Symbol*)_$1->info)->type = ((Token*)_$0->info)->type; if (!LookupSymbol(scopeStack, ((Symbol*)_$1->info)->name)) InsertSymbol(scopeStack, _$1->info); else printf("%s has already been defined.", ((Symbol*)_$1->info)->name);
return result;
}
            AbstractSyntaxTreeNode* semantic_121(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
MakeAbstractSyntaxTree(&result); result->info = NULL; *SetAbstractSyntaxTreeNodeChild(result) = _$0; *SetAbstractSyntaxTreeNodeChild(result) = _$2;
return result;
}
            AbstractSyntaxTreeNode* semantic_142(void *scopeStack, Stack *semanticStack)
                {
AbstractSyntaxTreeNode *result = NULL;
AbstractSyntaxTreeNode *_$3 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$2 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$1 = PopStack(semanticStack);
AbstractSyntaxTreeNode *_$0 = PopStack(semanticStack);
result = _$0; *SetAbstractSyntaxTreeNodeChild(_$0) = _$2;
return result;
}
            void InitGrammar(Grammar *grammar)
{
    InitLinearLinkedList(&grammar->nonTerminals);
    InitLinearLinkedList(&grammar->expressions);

    
NonTerminal *block_enter = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = block_enter;
block_enter->name = "block_enter";
block_enter->visited = FALSE;
InitLinearLinkedList(&block_enter->rules);
Expression *block_enterexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = block_enterexpression;
block_enterexpression->isTerminal = FALSE;
block_enterexpression->value.nonTerminal = block_enter;
block_enterexpression->visited = FALSE;
block_enterexpression->node = NULL;
NonTerminal *function_definition = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = function_definition;
function_definition->name = "function_definition";
function_definition->visited = FALSE;
InitLinearLinkedList(&function_definition->rules);
Expression *function_definitionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = function_definitionexpression;
function_definitionexpression->isTerminal = FALSE;
function_definitionexpression->value.nonTerminal = function_definition;
function_definitionexpression->visited = FALSE;
function_definitionexpression->node = NULL;
NonTerminal *external_declaration = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = external_declaration;
external_declaration->name = "external_declaration";
external_declaration->visited = FALSE;
InitLinearLinkedList(&external_declaration->rules);
Expression *external_declarationexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = external_declarationexpression;
external_declarationexpression->isTerminal = FALSE;
external_declarationexpression->value.nonTerminal = external_declaration;
external_declarationexpression->visited = FALSE;
external_declarationexpression->node = NULL;
NonTerminal *jump_statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = jump_statement;
jump_statement->name = "jump_statement";
jump_statement->visited = FALSE;
InitLinearLinkedList(&jump_statement->rules);
Expression *jump_statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = jump_statementexpression;
jump_statementexpression->isTerminal = FALSE;
jump_statementexpression->value.nonTerminal = jump_statement;
jump_statementexpression->visited = FALSE;
jump_statementexpression->node = NULL;
NonTerminal *iteration_statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = iteration_statement;
iteration_statement->name = "iteration_statement";
iteration_statement->visited = FALSE;
InitLinearLinkedList(&iteration_statement->rules);
Expression *iteration_statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = iteration_statementexpression;
iteration_statementexpression->isTerminal = FALSE;
iteration_statementexpression->value.nonTerminal = iteration_statement;
iteration_statementexpression->visited = FALSE;
iteration_statementexpression->node = NULL;
NonTerminal *selection_statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = selection_statement;
selection_statement->name = "selection_statement";
selection_statement->visited = FALSE;
InitLinearLinkedList(&selection_statement->rules);
Expression *selection_statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = selection_statementexpression;
selection_statementexpression->isTerminal = FALSE;
selection_statementexpression->value.nonTerminal = selection_statement;
selection_statementexpression->visited = FALSE;
selection_statementexpression->node = NULL;
NonTerminal *expression_statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = expression_statement;
expression_statement->name = "expression_statement";
expression_statement->visited = FALSE;
InitLinearLinkedList(&expression_statement->rules);
Expression *expression_statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = expression_statementexpression;
expression_statementexpression->isTerminal = FALSE;
expression_statementexpression->value.nonTerminal = expression_statement;
expression_statementexpression->visited = FALSE;
expression_statementexpression->node = NULL;
NonTerminal *statement_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = statement_list;
statement_list->name = "statement_list";
statement_list->visited = FALSE;
InitLinearLinkedList(&statement_list->rules);
Expression *statement_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = statement_listexpression;
statement_listexpression->isTerminal = FALSE;
statement_listexpression->value.nonTerminal = statement_list;
statement_listexpression->visited = FALSE;
statement_listexpression->node = NULL;
NonTerminal *declaration_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = declaration_list;
declaration_list->name = "declaration_list";
declaration_list->visited = FALSE;
InitLinearLinkedList(&declaration_list->rules);
Expression *declaration_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = declaration_listexpression;
declaration_listexpression->isTerminal = FALSE;
declaration_listexpression->value.nonTerminal = declaration_list;
declaration_listexpression->visited = FALSE;
declaration_listexpression->node = NULL;
NonTerminal *compound_statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = compound_statement;
compound_statement->name = "compound_statement";
compound_statement->visited = FALSE;
InitLinearLinkedList(&compound_statement->rules);
Expression *compound_statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = compound_statementexpression;
compound_statementexpression->isTerminal = FALSE;
compound_statementexpression->value.nonTerminal = compound_statement;
compound_statementexpression->visited = FALSE;
compound_statementexpression->node = NULL;
NonTerminal *labeled_statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = labeled_statement;
labeled_statement->name = "labeled_statement";
labeled_statement->visited = FALSE;
InitLinearLinkedList(&labeled_statement->rules);
Expression *labeled_statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = labeled_statementexpression;
labeled_statementexpression->isTerminal = FALSE;
labeled_statementexpression->value.nonTerminal = labeled_statement;
labeled_statementexpression->visited = FALSE;
labeled_statementexpression->node = NULL;
NonTerminal *statement = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = statement;
statement->name = "statement";
statement->visited = FALSE;
InitLinearLinkedList(&statement->rules);
Expression *statementexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = statementexpression;
statementexpression->isTerminal = FALSE;
statementexpression->value.nonTerminal = statement;
statementexpression->visited = FALSE;
statementexpression->node = NULL;
NonTerminal *initializer_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = initializer_list;
initializer_list->name = "initializer_list";
initializer_list->visited = FALSE;
InitLinearLinkedList(&initializer_list->rules);
Expression *initializer_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = initializer_listexpression;
initializer_listexpression->isTerminal = FALSE;
initializer_listexpression->value.nonTerminal = initializer_list;
initializer_listexpression->visited = FALSE;
initializer_listexpression->node = NULL;
NonTerminal *initializer = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = initializer;
initializer->name = "initializer";
initializer->visited = FALSE;
InitLinearLinkedList(&initializer->rules);
Expression *initializerexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = initializerexpression;
initializerexpression->isTerminal = FALSE;
initializerexpression->value.nonTerminal = initializer;
initializerexpression->visited = FALSE;
initializerexpression->node = NULL;
NonTerminal *direct_abstract_declarator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = direct_abstract_declarator;
direct_abstract_declarator->name = "direct_abstract_declarator";
direct_abstract_declarator->visited = FALSE;
InitLinearLinkedList(&direct_abstract_declarator->rules);
Expression *direct_abstract_declaratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = direct_abstract_declaratorexpression;
direct_abstract_declaratorexpression->isTerminal = FALSE;
direct_abstract_declaratorexpression->value.nonTerminal = direct_abstract_declarator;
direct_abstract_declaratorexpression->visited = FALSE;
direct_abstract_declaratorexpression->node = NULL;
NonTerminal *abstract_declarator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = abstract_declarator;
abstract_declarator->name = "abstract_declarator";
abstract_declarator->visited = FALSE;
InitLinearLinkedList(&abstract_declarator->rules);
Expression *abstract_declaratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = abstract_declaratorexpression;
abstract_declaratorexpression->isTerminal = FALSE;
abstract_declaratorexpression->value.nonTerminal = abstract_declarator;
abstract_declaratorexpression->visited = FALSE;
abstract_declaratorexpression->node = NULL;
NonTerminal *type_name = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = type_name;
type_name->name = "type_name";
type_name->visited = FALSE;
InitLinearLinkedList(&type_name->rules);
Expression *type_nameexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = type_nameexpression;
type_nameexpression->isTerminal = FALSE;
type_nameexpression->value.nonTerminal = type_name;
type_nameexpression->visited = FALSE;
type_nameexpression->node = NULL;
NonTerminal *identifier_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = identifier_list;
identifier_list->name = "identifier_list";
identifier_list->visited = FALSE;
InitLinearLinkedList(&identifier_list->rules);
Expression *identifier_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = identifier_listexpression;
identifier_listexpression->isTerminal = FALSE;
identifier_listexpression->value.nonTerminal = identifier_list;
identifier_listexpression->visited = FALSE;
identifier_listexpression->node = NULL;
NonTerminal *parameter_declaration = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = parameter_declaration;
parameter_declaration->name = "parameter_declaration";
parameter_declaration->visited = FALSE;
InitLinearLinkedList(&parameter_declaration->rules);
Expression *parameter_declarationexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = parameter_declarationexpression;
parameter_declarationexpression->isTerminal = FALSE;
parameter_declarationexpression->value.nonTerminal = parameter_declaration;
parameter_declarationexpression->visited = FALSE;
parameter_declarationexpression->node = NULL;
NonTerminal *parameter_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = parameter_list;
parameter_list->name = "parameter_list";
parameter_list->visited = FALSE;
InitLinearLinkedList(&parameter_list->rules);
Expression *parameter_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = parameter_listexpression;
parameter_listexpression->isTerminal = FALSE;
parameter_listexpression->value.nonTerminal = parameter_list;
parameter_listexpression->visited = FALSE;
parameter_listexpression->node = NULL;
NonTerminal *parameter_type_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = parameter_type_list;
parameter_type_list->name = "parameter_type_list";
parameter_type_list->visited = FALSE;
InitLinearLinkedList(&parameter_type_list->rules);
Expression *parameter_type_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = parameter_type_listexpression;
parameter_type_listexpression->isTerminal = FALSE;
parameter_type_listexpression->value.nonTerminal = parameter_type_list;
parameter_type_listexpression->visited = FALSE;
parameter_type_listexpression->node = NULL;
NonTerminal *type_qualifier_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = type_qualifier_list;
type_qualifier_list->name = "type_qualifier_list";
type_qualifier_list->visited = FALSE;
InitLinearLinkedList(&type_qualifier_list->rules);
Expression *type_qualifier_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = type_qualifier_listexpression;
type_qualifier_listexpression->isTerminal = FALSE;
type_qualifier_listexpression->value.nonTerminal = type_qualifier_list;
type_qualifier_listexpression->visited = FALSE;
type_qualifier_listexpression->node = NULL;
NonTerminal *pointer = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = pointer;
pointer->name = "pointer";
pointer->visited = FALSE;
InitLinearLinkedList(&pointer->rules);
Expression *pointerexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = pointerexpression;
pointerexpression->isTerminal = FALSE;
pointerexpression->value.nonTerminal = pointer;
pointerexpression->visited = FALSE;
pointerexpression->node = NULL;
NonTerminal *direct_declarator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = direct_declarator;
direct_declarator->name = "direct_declarator";
direct_declarator->visited = FALSE;
InitLinearLinkedList(&direct_declarator->rules);
Expression *direct_declaratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = direct_declaratorexpression;
direct_declaratorexpression->isTerminal = FALSE;
direct_declaratorexpression->value.nonTerminal = direct_declarator;
direct_declaratorexpression->visited = FALSE;
direct_declaratorexpression->node = NULL;
NonTerminal *declarator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = declarator;
declarator->name = "declarator";
declarator->visited = FALSE;
InitLinearLinkedList(&declarator->rules);
Expression *declaratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = declaratorexpression;
declaratorexpression->isTerminal = FALSE;
declaratorexpression->value.nonTerminal = declarator;
declaratorexpression->visited = FALSE;
declaratorexpression->node = NULL;
NonTerminal *type_qualifier = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = type_qualifier;
type_qualifier->name = "type_qualifier";
type_qualifier->visited = FALSE;
InitLinearLinkedList(&type_qualifier->rules);
Expression *type_qualifierexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = type_qualifierexpression;
type_qualifierexpression->isTerminal = FALSE;
type_qualifierexpression->value.nonTerminal = type_qualifier;
type_qualifierexpression->visited = FALSE;
type_qualifierexpression->node = NULL;
NonTerminal *enumerator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = enumerator;
enumerator->name = "enumerator";
enumerator->visited = FALSE;
InitLinearLinkedList(&enumerator->rules);
Expression *enumeratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = enumeratorexpression;
enumeratorexpression->isTerminal = FALSE;
enumeratorexpression->value.nonTerminal = enumerator;
enumeratorexpression->visited = FALSE;
enumeratorexpression->node = NULL;
NonTerminal *enumerator_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = enumerator_list;
enumerator_list->name = "enumerator_list";
enumerator_list->visited = FALSE;
InitLinearLinkedList(&enumerator_list->rules);
Expression *enumerator_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = enumerator_listexpression;
enumerator_listexpression->isTerminal = FALSE;
enumerator_listexpression->value.nonTerminal = enumerator_list;
enumerator_listexpression->visited = FALSE;
enumerator_listexpression->node = NULL;
NonTerminal *enum_specifier = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = enum_specifier;
enum_specifier->name = "enum_specifier";
enum_specifier->visited = FALSE;
InitLinearLinkedList(&enum_specifier->rules);
Expression *enum_specifierexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = enum_specifierexpression;
enum_specifierexpression->isTerminal = FALSE;
enum_specifierexpression->value.nonTerminal = enum_specifier;
enum_specifierexpression->visited = FALSE;
enum_specifierexpression->node = NULL;
NonTerminal *struct_declarator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = struct_declarator;
struct_declarator->name = "struct_declarator";
struct_declarator->visited = FALSE;
InitLinearLinkedList(&struct_declarator->rules);
Expression *struct_declaratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = struct_declaratorexpression;
struct_declaratorexpression->isTerminal = FALSE;
struct_declaratorexpression->value.nonTerminal = struct_declarator;
struct_declaratorexpression->visited = FALSE;
struct_declaratorexpression->node = NULL;
NonTerminal *struct_declarator_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = struct_declarator_list;
struct_declarator_list->name = "struct_declarator_list";
struct_declarator_list->visited = FALSE;
InitLinearLinkedList(&struct_declarator_list->rules);
Expression *struct_declarator_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = struct_declarator_listexpression;
struct_declarator_listexpression->isTerminal = FALSE;
struct_declarator_listexpression->value.nonTerminal = struct_declarator_list;
struct_declarator_listexpression->visited = FALSE;
struct_declarator_listexpression->node = NULL;
NonTerminal *specifier_qualifier_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = specifier_qualifier_list;
specifier_qualifier_list->name = "specifier_qualifier_list";
specifier_qualifier_list->visited = FALSE;
InitLinearLinkedList(&specifier_qualifier_list->rules);
Expression *specifier_qualifier_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = specifier_qualifier_listexpression;
specifier_qualifier_listexpression->isTerminal = FALSE;
specifier_qualifier_listexpression->value.nonTerminal = specifier_qualifier_list;
specifier_qualifier_listexpression->visited = FALSE;
specifier_qualifier_listexpression->node = NULL;
NonTerminal *struct_declaration = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = struct_declaration;
struct_declaration->name = "struct_declaration";
struct_declaration->visited = FALSE;
InitLinearLinkedList(&struct_declaration->rules);
Expression *struct_declarationexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = struct_declarationexpression;
struct_declarationexpression->isTerminal = FALSE;
struct_declarationexpression->value.nonTerminal = struct_declaration;
struct_declarationexpression->visited = FALSE;
struct_declarationexpression->node = NULL;
NonTerminal *struct_declaration_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = struct_declaration_list;
struct_declaration_list->name = "struct_declaration_list";
struct_declaration_list->visited = FALSE;
InitLinearLinkedList(&struct_declaration_list->rules);
Expression *struct_declaration_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = struct_declaration_listexpression;
struct_declaration_listexpression->isTerminal = FALSE;
struct_declaration_listexpression->value.nonTerminal = struct_declaration_list;
struct_declaration_listexpression->visited = FALSE;
struct_declaration_listexpression->node = NULL;
NonTerminal *struct_or_union = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = struct_or_union;
struct_or_union->name = "struct_or_union";
struct_or_union->visited = FALSE;
InitLinearLinkedList(&struct_or_union->rules);
Expression *struct_or_unionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = struct_or_unionexpression;
struct_or_unionexpression->isTerminal = FALSE;
struct_or_unionexpression->value.nonTerminal = struct_or_union;
struct_or_unionexpression->visited = FALSE;
struct_or_unionexpression->node = NULL;
NonTerminal *struct_or_union_specifier = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = struct_or_union_specifier;
struct_or_union_specifier->name = "struct_or_union_specifier";
struct_or_union_specifier->visited = FALSE;
InitLinearLinkedList(&struct_or_union_specifier->rules);
Expression *struct_or_union_specifierexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = struct_or_union_specifierexpression;
struct_or_union_specifierexpression->isTerminal = FALSE;
struct_or_union_specifierexpression->value.nonTerminal = struct_or_union_specifier;
struct_or_union_specifierexpression->visited = FALSE;
struct_or_union_specifierexpression->node = NULL;
NonTerminal *type_specifier = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = type_specifier;
type_specifier->name = "type_specifier";
type_specifier->visited = FALSE;
InitLinearLinkedList(&type_specifier->rules);
Expression *type_specifierexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = type_specifierexpression;
type_specifierexpression->isTerminal = FALSE;
type_specifierexpression->value.nonTerminal = type_specifier;
type_specifierexpression->visited = FALSE;
type_specifierexpression->node = NULL;
NonTerminal *storage_class_specifier = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = storage_class_specifier;
storage_class_specifier->name = "storage_class_specifier";
storage_class_specifier->visited = FALSE;
InitLinearLinkedList(&storage_class_specifier->rules);
Expression *storage_class_specifierexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = storage_class_specifierexpression;
storage_class_specifierexpression->isTerminal = FALSE;
storage_class_specifierexpression->value.nonTerminal = storage_class_specifier;
storage_class_specifierexpression->visited = FALSE;
storage_class_specifierexpression->node = NULL;
NonTerminal *init_declarator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = init_declarator;
init_declarator->name = "init_declarator";
init_declarator->visited = FALSE;
InitLinearLinkedList(&init_declarator->rules);
Expression *init_declaratorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = init_declaratorexpression;
init_declaratorexpression->isTerminal = FALSE;
init_declaratorexpression->value.nonTerminal = init_declarator;
init_declaratorexpression->visited = FALSE;
init_declaratorexpression->node = NULL;
NonTerminal *init_declarator_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = init_declarator_list;
init_declarator_list->name = "init_declarator_list";
init_declarator_list->visited = FALSE;
InitLinearLinkedList(&init_declarator_list->rules);
Expression *init_declarator_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = init_declarator_listexpression;
init_declarator_listexpression->isTerminal = FALSE;
init_declarator_listexpression->value.nonTerminal = init_declarator_list;
init_declarator_listexpression->visited = FALSE;
init_declarator_listexpression->node = NULL;
NonTerminal *declaration_specifiers = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = declaration_specifiers;
declaration_specifiers->name = "declaration_specifiers";
declaration_specifiers->visited = FALSE;
InitLinearLinkedList(&declaration_specifiers->rules);
Expression *declaration_specifiersexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = declaration_specifiersexpression;
declaration_specifiersexpression->isTerminal = FALSE;
declaration_specifiersexpression->value.nonTerminal = declaration_specifiers;
declaration_specifiersexpression->visited = FALSE;
declaration_specifiersexpression->node = NULL;
NonTerminal *declaration = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = declaration;
declaration->name = "declaration";
declaration->visited = FALSE;
InitLinearLinkedList(&declaration->rules);
Expression *declarationexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = declarationexpression;
declarationexpression->isTerminal = FALSE;
declarationexpression->value.nonTerminal = declaration;
declarationexpression->visited = FALSE;
declarationexpression->node = NULL;
NonTerminal *constant_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = constant_expression;
constant_expression->name = "constant_expression";
constant_expression->visited = FALSE;
InitLinearLinkedList(&constant_expression->rules);
Expression *constant_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = constant_expressionexpression;
constant_expressionexpression->isTerminal = FALSE;
constant_expressionexpression->value.nonTerminal = constant_expression;
constant_expressionexpression->visited = FALSE;
constant_expressionexpression->node = NULL;
NonTerminal *expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = expression;
expression->name = "expression";
expression->visited = FALSE;
InitLinearLinkedList(&expression->rules);
Expression *expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = expressionexpression;
expressionexpression->isTerminal = FALSE;
expressionexpression->value.nonTerminal = expression;
expressionexpression->visited = FALSE;
expressionexpression->node = NULL;
NonTerminal *assignment_operator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = assignment_operator;
assignment_operator->name = "assignment_operator";
assignment_operator->visited = FALSE;
InitLinearLinkedList(&assignment_operator->rules);
Expression *assignment_operatorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = assignment_operatorexpression;
assignment_operatorexpression->isTerminal = FALSE;
assignment_operatorexpression->value.nonTerminal = assignment_operator;
assignment_operatorexpression->visited = FALSE;
assignment_operatorexpression->node = NULL;
NonTerminal *assignment_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = assignment_expression;
assignment_expression->name = "assignment_expression";
assignment_expression->visited = FALSE;
InitLinearLinkedList(&assignment_expression->rules);
Expression *assignment_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = assignment_expressionexpression;
assignment_expressionexpression->isTerminal = FALSE;
assignment_expressionexpression->value.nonTerminal = assignment_expression;
assignment_expressionexpression->visited = FALSE;
assignment_expressionexpression->node = NULL;
NonTerminal *conditional_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = conditional_expression;
conditional_expression->name = "conditional_expression";
conditional_expression->visited = FALSE;
InitLinearLinkedList(&conditional_expression->rules);
Expression *conditional_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = conditional_expressionexpression;
conditional_expressionexpression->isTerminal = FALSE;
conditional_expressionexpression->value.nonTerminal = conditional_expression;
conditional_expressionexpression->visited = FALSE;
conditional_expressionexpression->node = NULL;
NonTerminal *logical_or_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = logical_or_expression;
logical_or_expression->name = "logical_or_expression";
logical_or_expression->visited = FALSE;
InitLinearLinkedList(&logical_or_expression->rules);
Expression *logical_or_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = logical_or_expressionexpression;
logical_or_expressionexpression->isTerminal = FALSE;
logical_or_expressionexpression->value.nonTerminal = logical_or_expression;
logical_or_expressionexpression->visited = FALSE;
logical_or_expressionexpression->node = NULL;
NonTerminal *logical_and_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = logical_and_expression;
logical_and_expression->name = "logical_and_expression";
logical_and_expression->visited = FALSE;
InitLinearLinkedList(&logical_and_expression->rules);
Expression *logical_and_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = logical_and_expressionexpression;
logical_and_expressionexpression->isTerminal = FALSE;
logical_and_expressionexpression->value.nonTerminal = logical_and_expression;
logical_and_expressionexpression->visited = FALSE;
logical_and_expressionexpression->node = NULL;
NonTerminal *inclusive_or_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = inclusive_or_expression;
inclusive_or_expression->name = "inclusive_or_expression";
inclusive_or_expression->visited = FALSE;
InitLinearLinkedList(&inclusive_or_expression->rules);
Expression *inclusive_or_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = inclusive_or_expressionexpression;
inclusive_or_expressionexpression->isTerminal = FALSE;
inclusive_or_expressionexpression->value.nonTerminal = inclusive_or_expression;
inclusive_or_expressionexpression->visited = FALSE;
inclusive_or_expressionexpression->node = NULL;
NonTerminal *exclusive_or_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = exclusive_or_expression;
exclusive_or_expression->name = "exclusive_or_expression";
exclusive_or_expression->visited = FALSE;
InitLinearLinkedList(&exclusive_or_expression->rules);
Expression *exclusive_or_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = exclusive_or_expressionexpression;
exclusive_or_expressionexpression->isTerminal = FALSE;
exclusive_or_expressionexpression->value.nonTerminal = exclusive_or_expression;
exclusive_or_expressionexpression->visited = FALSE;
exclusive_or_expressionexpression->node = NULL;
NonTerminal *and_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = and_expression;
and_expression->name = "and_expression";
and_expression->visited = FALSE;
InitLinearLinkedList(&and_expression->rules);
Expression *and_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = and_expressionexpression;
and_expressionexpression->isTerminal = FALSE;
and_expressionexpression->value.nonTerminal = and_expression;
and_expressionexpression->visited = FALSE;
and_expressionexpression->node = NULL;
NonTerminal *equality_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = equality_expression;
equality_expression->name = "equality_expression";
equality_expression->visited = FALSE;
InitLinearLinkedList(&equality_expression->rules);
Expression *equality_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = equality_expressionexpression;
equality_expressionexpression->isTerminal = FALSE;
equality_expressionexpression->value.nonTerminal = equality_expression;
equality_expressionexpression->visited = FALSE;
equality_expressionexpression->node = NULL;
NonTerminal *relational_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = relational_expression;
relational_expression->name = "relational_expression";
relational_expression->visited = FALSE;
InitLinearLinkedList(&relational_expression->rules);
Expression *relational_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = relational_expressionexpression;
relational_expressionexpression->isTerminal = FALSE;
relational_expressionexpression->value.nonTerminal = relational_expression;
relational_expressionexpression->visited = FALSE;
relational_expressionexpression->node = NULL;
NonTerminal *shift_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = shift_expression;
shift_expression->name = "shift_expression";
shift_expression->visited = FALSE;
InitLinearLinkedList(&shift_expression->rules);
Expression *shift_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = shift_expressionexpression;
shift_expressionexpression->isTerminal = FALSE;
shift_expressionexpression->value.nonTerminal = shift_expression;
shift_expressionexpression->visited = FALSE;
shift_expressionexpression->node = NULL;
NonTerminal *additive_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = additive_expression;
additive_expression->name = "additive_expression";
additive_expression->visited = FALSE;
InitLinearLinkedList(&additive_expression->rules);
Expression *additive_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = additive_expressionexpression;
additive_expressionexpression->isTerminal = FALSE;
additive_expressionexpression->value.nonTerminal = additive_expression;
additive_expressionexpression->visited = FALSE;
additive_expressionexpression->node = NULL;
NonTerminal *multiplicative_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = multiplicative_expression;
multiplicative_expression->name = "multiplicative_expression";
multiplicative_expression->visited = FALSE;
InitLinearLinkedList(&multiplicative_expression->rules);
Expression *multiplicative_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = multiplicative_expressionexpression;
multiplicative_expressionexpression->isTerminal = FALSE;
multiplicative_expressionexpression->value.nonTerminal = multiplicative_expression;
multiplicative_expressionexpression->visited = FALSE;
multiplicative_expressionexpression->node = NULL;
NonTerminal *cast_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = cast_expression;
cast_expression->name = "cast_expression";
cast_expression->visited = FALSE;
InitLinearLinkedList(&cast_expression->rules);
Expression *cast_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = cast_expressionexpression;
cast_expressionexpression->isTerminal = FALSE;
cast_expressionexpression->value.nonTerminal = cast_expression;
cast_expressionexpression->visited = FALSE;
cast_expressionexpression->node = NULL;
NonTerminal *unary_operator = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = unary_operator;
unary_operator->name = "unary_operator";
unary_operator->visited = FALSE;
InitLinearLinkedList(&unary_operator->rules);
Expression *unary_operatorexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = unary_operatorexpression;
unary_operatorexpression->isTerminal = FALSE;
unary_operatorexpression->value.nonTerminal = unary_operator;
unary_operatorexpression->visited = FALSE;
unary_operatorexpression->node = NULL;
NonTerminal *unary_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = unary_expression;
unary_expression->name = "unary_expression";
unary_expression->visited = FALSE;
InitLinearLinkedList(&unary_expression->rules);
Expression *unary_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = unary_expressionexpression;
unary_expressionexpression->isTerminal = FALSE;
unary_expressionexpression->value.nonTerminal = unary_expression;
unary_expressionexpression->visited = FALSE;
unary_expressionexpression->node = NULL;
NonTerminal *argument_expression_list = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = argument_expression_list;
argument_expression_list->name = "argument_expression_list";
argument_expression_list->visited = FALSE;
InitLinearLinkedList(&argument_expression_list->rules);
Expression *argument_expression_listexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = argument_expression_listexpression;
argument_expression_listexpression->isTerminal = FALSE;
argument_expression_listexpression->value.nonTerminal = argument_expression_list;
argument_expression_listexpression->visited = FALSE;
argument_expression_listexpression->node = NULL;
NonTerminal *postfix_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = postfix_expression;
postfix_expression->name = "postfix_expression";
postfix_expression->visited = FALSE;
InitLinearLinkedList(&postfix_expression->rules);
Expression *postfix_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = postfix_expressionexpression;
postfix_expressionexpression->isTerminal = FALSE;
postfix_expressionexpression->value.nonTerminal = postfix_expression;
postfix_expressionexpression->visited = FALSE;
postfix_expressionexpression->node = NULL;
NonTerminal *primary_expression = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = primary_expression;
primary_expression->name = "primary_expression";
primary_expression->visited = FALSE;
InitLinearLinkedList(&primary_expression->rules);
Expression *primary_expressionexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = primary_expressionexpression;
primary_expressionexpression->isTerminal = FALSE;
primary_expressionexpression->value.nonTerminal = primary_expression;
primary_expressionexpression->visited = FALSE;
primary_expressionexpression->node = NULL;
NonTerminal *translation_unit = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = translation_unit;
translation_unit->name = "translation_unit";
translation_unit->visited = FALSE;
InitLinearLinkedList(&translation_unit->rules);
Expression *translation_unitexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = translation_unitexpression;
translation_unitexpression->isTerminal = FALSE;
translation_unitexpression->value.nonTerminal = translation_unit;
translation_unitexpression->visited = FALSE;
translation_unitexpression->node = NULL;
NonTerminal *start = malloc(sizeof(NonTerminal));
PushLinearLinkedList(&grammar->nonTerminals);
grammar->nonTerminals->info = start;
start->name = "start";
start->visited = FALSE;
InitLinearLinkedList(&start->rules);
Expression *startexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = startexpression;
startexpression->isTerminal = FALSE;
startexpression->value.nonTerminal = start;
startexpression->visited = FALSE;
startexpression->node = NULL;
Expression *MOD_EQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = MOD_EQexpression;
MOD_EQexpression->isTerminal = TRUE;
MOD_EQexpression->value.terminal = MOD_EQ;
MOD_EQexpression->visited = FALSE;
MOD_EQexpression->node = NULL;
Expression *SLASH_EQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = SLASH_EQexpression;
SLASH_EQexpression->isTerminal = TRUE;
SLASH_EQexpression->value.terminal = SLASH_EQ;
SLASH_EQexpression->visited = FALSE;
SLASH_EQexpression->node = NULL;
Expression *STAR_EQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = STAR_EQexpression;
STAR_EQexpression->isTerminal = TRUE;
STAR_EQexpression->value.terminal = STAR_EQ;
STAR_EQexpression->visited = FALSE;
STAR_EQexpression->node = NULL;
Expression *MINUS_EQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = MINUS_EQexpression;
MINUS_EQexpression->isTerminal = TRUE;
MINUS_EQexpression->value.terminal = MINUS_EQ;
MINUS_EQexpression->visited = FALSE;
MINUS_EQexpression->node = NULL;
Expression *PLUS_EQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = PLUS_EQexpression;
PLUS_EQexpression->isTerminal = TRUE;
PLUS_EQexpression->value.terminal = PLUS_EQ;
PLUS_EQexpression->visited = FALSE;
PLUS_EQexpression->node = NULL;
Expression *MINUS_MINUSexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = MINUS_MINUSexpression;
MINUS_MINUSexpression->isTerminal = TRUE;
MINUS_MINUSexpression->value.terminal = MINUS_MINUS;
MINUS_MINUSexpression->visited = FALSE;
MINUS_MINUSexpression->node = NULL;
Expression *PLUS_PLUSexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = PLUS_PLUSexpression;
PLUS_PLUSexpression->isTerminal = TRUE;
PLUS_PLUSexpression->value.terminal = PLUS_PLUS;
PLUS_PLUSexpression->visited = FALSE;
PLUS_PLUSexpression->node = NULL;
Expression *INTEGER_LITERALexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = INTEGER_LITERALexpression;
INTEGER_LITERALexpression->isTerminal = TRUE;
INTEGER_LITERALexpression->value.terminal = INTEGER_LITERAL;
INTEGER_LITERALexpression->visited = FALSE;
INTEGER_LITERALexpression->node = NULL;
Expression *FLOAT_LITERALexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = FLOAT_LITERALexpression;
FLOAT_LITERALexpression->isTerminal = TRUE;
FLOAT_LITERALexpression->value.terminal = FLOAT_LITERAL;
FLOAT_LITERALexpression->visited = FALSE;
FLOAT_LITERALexpression->node = NULL;
Expression *AMPERSANDexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = AMPERSANDexpression;
AMPERSANDexpression->isTerminal = TRUE;
AMPERSANDexpression->value.terminal = AMPERSAND;
AMPERSANDexpression->visited = FALSE;
AMPERSANDexpression->node = NULL;
Expression *RIGHT_PARENexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = RIGHT_PARENexpression;
RIGHT_PARENexpression->isTerminal = TRUE;
RIGHT_PARENexpression->value.terminal = RIGHT_PAREN;
RIGHT_PARENexpression->visited = FALSE;
RIGHT_PARENexpression->node = NULL;
Expression *LEFT_PARENexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = LEFT_PARENexpression;
LEFT_PARENexpression->isTerminal = TRUE;
LEFT_PARENexpression->value.terminal = LEFT_PAREN;
LEFT_PARENexpression->visited = FALSE;
LEFT_PARENexpression->node = NULL;
Expression *RIGHT_CURLYexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = RIGHT_CURLYexpression;
RIGHT_CURLYexpression->isTerminal = TRUE;
RIGHT_CURLYexpression->value.terminal = RIGHT_CURLY;
RIGHT_CURLYexpression->visited = FALSE;
RIGHT_CURLYexpression->node = NULL;
Expression *LEFT_CURLYexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = LEFT_CURLYexpression;
LEFT_CURLYexpression->isTerminal = TRUE;
LEFT_CURLYexpression->value.terminal = LEFT_CURLY;
LEFT_CURLYexpression->visited = FALSE;
LEFT_CURLYexpression->node = NULL;
Expression *RIGHT_BRACKETexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = RIGHT_BRACKETexpression;
RIGHT_BRACKETexpression->isTerminal = TRUE;
RIGHT_BRACKETexpression->value.terminal = RIGHT_BRACKET;
RIGHT_BRACKETexpression->visited = FALSE;
RIGHT_BRACKETexpression->node = NULL;
Expression *LEFT_BRACKETexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = LEFT_BRACKETexpression;
LEFT_BRACKETexpression->isTerminal = TRUE;
LEFT_BRACKETexpression->value.terminal = LEFT_BRACKET;
LEFT_BRACKETexpression->visited = FALSE;
LEFT_BRACKETexpression->node = NULL;
Expression *SEMI_COLONexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = SEMI_COLONexpression;
SEMI_COLONexpression->isTerminal = TRUE;
SEMI_COLONexpression->value.terminal = SEMI_COLON;
SEMI_COLONexpression->visited = FALSE;
SEMI_COLONexpression->node = NULL;
Expression *COMMAexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = COMMAexpression;
COMMAexpression->isTerminal = TRUE;
COMMAexpression->value.terminal = COMMA;
COMMAexpression->visited = FALSE;
COMMAexpression->node = NULL;
Expression *ARROWexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = ARROWexpression;
ARROWexpression->isTerminal = TRUE;
ARROWexpression->value.terminal = ARROW;
ARROWexpression->visited = FALSE;
ARROWexpression->node = NULL;
Expression *DOTexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = DOTexpression;
DOTexpression->isTerminal = TRUE;
DOTexpression->value.terminal = DOT;
DOTexpression->visited = FALSE;
DOTexpression->node = NULL;
Expression *MODexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = MODexpression;
MODexpression->isTerminal = TRUE;
MODexpression->value.terminal = MOD;
MODexpression->visited = FALSE;
MODexpression->node = NULL;
Expression *SLASHexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = SLASHexpression;
SLASHexpression->isTerminal = TRUE;
SLASHexpression->value.terminal = SLASH;
SLASHexpression->visited = FALSE;
SLASHexpression->node = NULL;
Expression *STARexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = STARexpression;
STARexpression->isTerminal = TRUE;
STARexpression->value.terminal = STAR;
STARexpression->visited = FALSE;
STARexpression->node = NULL;
Expression *NEQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = NEQexpression;
NEQexpression->isTerminal = TRUE;
NEQexpression->value.terminal = NEQ;
NEQexpression->visited = FALSE;
NEQexpression->node = NULL;
Expression *EEQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = EEQexpression;
EEQexpression->isTerminal = TRUE;
EEQexpression->value.terminal = EEQ;
EEQexpression->visited = FALSE;
EEQexpression->node = NULL;
Expression *LEexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = LEexpression;
LEexpression->isTerminal = TRUE;
LEexpression->value.terminal = LE;
LEexpression->visited = FALSE;
LEexpression->node = NULL;
Expression *GEexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = GEexpression;
GEexpression->isTerminal = TRUE;
GEexpression->value.terminal = GE;
GEexpression->visited = FALSE;
GEexpression->node = NULL;
Expression *EQexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = EQexpression;
EQexpression->isTerminal = TRUE;
EQexpression->value.terminal = EQ;
EQexpression->visited = FALSE;
EQexpression->node = NULL;
Expression *LTexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = LTexpression;
LTexpression->isTerminal = TRUE;
LTexpression->value.terminal = LT;
LTexpression->visited = FALSE;
LTexpression->node = NULL;
Expression *GTexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = GTexpression;
GTexpression->isTerminal = TRUE;
GTexpression->value.terminal = GT;
GTexpression->visited = FALSE;
GTexpression->node = NULL;
Expression *MINUSexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = MINUSexpression;
MINUSexpression->isTerminal = TRUE;
MINUSexpression->value.terminal = MINUS;
MINUSexpression->visited = FALSE;
MINUSexpression->node = NULL;
Expression *PLUSexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = PLUSexpression;
PLUSexpression->isTerminal = TRUE;
PLUSexpression->value.terminal = PLUS;
PLUSexpression->visited = FALSE;
PLUSexpression->node = NULL;
Expression *RETURNexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = RETURNexpression;
RETURNexpression->isTerminal = TRUE;
RETURNexpression->value.terminal = RETURN;
RETURNexpression->visited = FALSE;
RETURNexpression->node = NULL;
Expression *WHILEexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = WHILEexpression;
WHILEexpression->isTerminal = TRUE;
WHILEexpression->value.terminal = WHILE;
WHILEexpression->visited = FALSE;
WHILEexpression->node = NULL;
Expression *ELSEexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = ELSEexpression;
ELSEexpression->isTerminal = TRUE;
ELSEexpression->value.terminal = ELSE;
ELSEexpression->visited = FALSE;
ELSEexpression->node = NULL;
Expression *IFexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = IFexpression;
IFexpression->isTerminal = TRUE;
IFexpression->value.terminal = IF;
IFexpression->visited = FALSE;
IFexpression->node = NULL;
Expression *FORexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = FORexpression;
FORexpression->isTerminal = TRUE;
FORexpression->value.terminal = FOR;
FORexpression->visited = FALSE;
FORexpression->node = NULL;
Expression *STRUCTexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = STRUCTexpression;
STRUCTexpression->isTerminal = TRUE;
STRUCTexpression->value.terminal = STRUCT;
STRUCTexpression->visited = FALSE;
STRUCTexpression->node = NULL;
Expression *UNSIGNEDexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = UNSIGNEDexpression;
UNSIGNEDexpression->isTerminal = TRUE;
UNSIGNEDexpression->value.terminal = UNSIGNED;
UNSIGNEDexpression->visited = FALSE;
UNSIGNEDexpression->node = NULL;
Expression *CHARexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = CHARexpression;
CHARexpression->isTerminal = TRUE;
CHARexpression->value.terminal = CHAR;
CHARexpression->visited = FALSE;
CHARexpression->node = NULL;
Expression *SHORTexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = SHORTexpression;
SHORTexpression->isTerminal = TRUE;
SHORTexpression->value.terminal = SHORT;
SHORTexpression->visited = FALSE;
SHORTexpression->node = NULL;
Expression *DOUBLEexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = DOUBLEexpression;
DOUBLEexpression->isTerminal = TRUE;
DOUBLEexpression->value.terminal = DOUBLE;
DOUBLEexpression->visited = FALSE;
DOUBLEexpression->node = NULL;
Expression *LONGexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = LONGexpression;
LONGexpression->isTerminal = TRUE;
LONGexpression->value.terminal = LONG;
LONGexpression->visited = FALSE;
LONGexpression->node = NULL;
Expression *FLOATexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = FLOATexpression;
FLOATexpression->isTerminal = TRUE;
FLOATexpression->value.terminal = FLOAT;
FLOATexpression->visited = FALSE;
FLOATexpression->node = NULL;
Expression *INTexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = INTexpression;
INTexpression->isTerminal = TRUE;
INTexpression->value.terminal = INT;
INTexpression->visited = FALSE;
INTexpression->node = NULL;
Expression *MAINexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = MAINexpression;
MAINexpression->isTerminal = TRUE;
MAINexpression->value.terminal = MAIN;
MAINexpression->visited = FALSE;
MAINexpression->node = NULL;
Expression *VOIDexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = VOIDexpression;
VOIDexpression->isTerminal = TRUE;
VOIDexpression->value.terminal = VOID;
VOIDexpression->visited = FALSE;
VOIDexpression->node = NULL;
Expression *IDENTIFIERexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = IDENTIFIERexpression;
IDENTIFIERexpression->isTerminal = TRUE;
IDENTIFIERexpression->value.terminal = IDENTIFIER;
IDENTIFIERexpression->visited = FALSE;
IDENTIFIERexpression->node = NULL;
Expression *STRING_LITERALexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = STRING_LITERALexpression;
STRING_LITERALexpression->isTerminal = TRUE;
STRING_LITERALexpression->value.terminal = STRING_LITERAL;
STRING_LITERALexpression->visited = FALSE;
STRING_LITERALexpression->node = NULL;
Expression *EODexpression = malloc(sizeof(Expression));
PushLinearLinkedList(&grammar->expressions);
grammar->expressions->info = EODexpression;
EODexpression->isTerminal = TRUE;
EODexpression->value.terminal = EOD;
EODexpression->visited = FALSE;
EODexpression->node = NULL;
Rule *rule_0 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_0->expressions);
        rule_0->semanticAction = NULL;
        rule_0->nonTerminal = start;
PushLinearLinkedList(&rule_0->expressions);
rule_0->expressions->info = translation_unitexpression;
PushLinearLinkedList(&start->rules);
start->rules->info = rule_0;
Rule *rule_1 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_1->expressions);
        rule_1->semanticAction = NULL;
        rule_1->nonTerminal = translation_unit;
rule_1->semanticAction = semantic_1;
PushLinearLinkedList(&rule_1->expressions);
rule_1->expressions->info = external_declarationexpression;
PushLinearLinkedList(&translation_unit->rules);
translation_unit->rules->info = rule_1;
Rule *rule_2 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_2->expressions);
        rule_2->semanticAction = NULL;
        rule_2->nonTerminal = translation_unit;
rule_2->semanticAction = semantic_2;
PushLinearLinkedList(&rule_2->expressions);
rule_2->expressions->info = external_declarationexpression;
PushLinearLinkedList(&rule_2->expressions);
rule_2->expressions->info = translation_unitexpression;
PushLinearLinkedList(&translation_unit->rules);
translation_unit->rules->info = rule_2;
Rule *rule_3 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_3->expressions);
        rule_3->semanticAction = NULL;
        rule_3->nonTerminal = external_declaration;
PushLinearLinkedList(&rule_3->expressions);
rule_3->expressions->info = function_definitionexpression;
PushLinearLinkedList(&external_declaration->rules);
external_declaration->rules->info = rule_3;
Rule *rule_4 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_4->expressions);
        rule_4->semanticAction = NULL;
        rule_4->nonTerminal = external_declaration;
PushLinearLinkedList(&rule_4->expressions);
rule_4->expressions->info = declarationexpression;
PushLinearLinkedList(&external_declaration->rules);
external_declaration->rules->info = rule_4;
Rule *rule_5 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_5->expressions);
        rule_5->semanticAction = NULL;
        rule_5->nonTerminal = function_definition;
rule_5->semanticAction = semantic_5;
PushLinearLinkedList(&rule_5->expressions);
rule_5->expressions->info = compound_statementexpression;
PushLinearLinkedList(&rule_5->expressions);
rule_5->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_5->expressions);
rule_5->expressions->info = parameter_listexpression;
PushLinearLinkedList(&rule_5->expressions);
rule_5->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_5->expressions);
rule_5->expressions->info = direct_declaratorexpression;
PushLinearLinkedList(&rule_5->expressions);
rule_5->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&function_definition->rules);
function_definition->rules->info = rule_5;
Rule *rule_6 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_6->expressions);
        rule_6->semanticAction = NULL;
        rule_6->nonTerminal = function_definition;
rule_6->semanticAction = semantic_6;
PushLinearLinkedList(&rule_6->expressions);
rule_6->expressions->info = compound_statementexpression;
PushLinearLinkedList(&rule_6->expressions);
rule_6->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_6->expressions);
rule_6->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_6->expressions);
rule_6->expressions->info = direct_declaratorexpression;
PushLinearLinkedList(&rule_6->expressions);
rule_6->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&function_definition->rules);
function_definition->rules->info = rule_6;
Rule *rule_7 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_7->expressions);
        rule_7->semanticAction = NULL;
        rule_7->nonTerminal = function_definition;
PushLinearLinkedList(&rule_7->expressions);
rule_7->expressions->info = compound_statementexpression;
PushLinearLinkedList(&rule_7->expressions);
rule_7->expressions->info = declaration_listexpression;
PushLinearLinkedList(&rule_7->expressions);
rule_7->expressions->info = direct_declaratorexpression;
PushLinearLinkedList(&function_definition->rules);
function_definition->rules->info = rule_7;
Rule *rule_8 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_8->expressions);
        rule_8->semanticAction = NULL;
        rule_8->nonTerminal = function_definition;
PushLinearLinkedList(&rule_8->expressions);
rule_8->expressions->info = compound_statementexpression;
PushLinearLinkedList(&rule_8->expressions);
rule_8->expressions->info = direct_declaratorexpression;
PushLinearLinkedList(&function_definition->rules);
function_definition->rules->info = rule_8;
Rule *rule_9 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_9->expressions);
        rule_9->semanticAction = NULL;
        rule_9->nonTerminal = jump_statement;
PushLinearLinkedList(&rule_9->expressions);
rule_9->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&rule_9->expressions);
rule_9->expressions->info = RETURNexpression;
PushLinearLinkedList(&jump_statement->rules);
jump_statement->rules->info = rule_9;
Rule *rule_10 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_10->expressions);
        rule_10->semanticAction = NULL;
        rule_10->nonTerminal = jump_statement;
PushLinearLinkedList(&rule_10->expressions);
rule_10->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&rule_10->expressions);
rule_10->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_10->expressions);
rule_10->expressions->info = RETURNexpression;
PushLinearLinkedList(&jump_statement->rules);
jump_statement->rules->info = rule_10;
Rule *rule_11 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_11->expressions);
        rule_11->semanticAction = NULL;
        rule_11->nonTerminal = iteration_statement;
rule_11->semanticAction = semantic_11;
PushLinearLinkedList(&rule_11->expressions);
rule_11->expressions->info = statementexpression;
PushLinearLinkedList(&rule_11->expressions);
rule_11->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_11->expressions);
rule_11->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_11->expressions);
rule_11->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_11->expressions);
rule_11->expressions->info = WHILEexpression;
PushLinearLinkedList(&iteration_statement->rules);
iteration_statement->rules->info = rule_11;
Rule *rule_12 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_12->expressions);
        rule_12->semanticAction = NULL;
        rule_12->nonTerminal = iteration_statement;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = statementexpression;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = expression_statementexpression;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = declarationexpression;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_12->expressions);
rule_12->expressions->info = FORexpression;
PushLinearLinkedList(&iteration_statement->rules);
iteration_statement->rules->info = rule_12;
Rule *rule_13 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_13->expressions);
        rule_13->semanticAction = NULL;
        rule_13->nonTerminal = iteration_statement;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = statementexpression;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = expression_statementexpression;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = expression_statementexpression;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_13->expressions);
rule_13->expressions->info = FORexpression;
PushLinearLinkedList(&iteration_statement->rules);
iteration_statement->rules->info = rule_13;
Rule *rule_14 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_14->expressions);
        rule_14->semanticAction = NULL;
        rule_14->nonTerminal = selection_statement;
PushLinearLinkedList(&rule_14->expressions);
rule_14->expressions->info = statementexpression;
PushLinearLinkedList(&rule_14->expressions);
rule_14->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_14->expressions);
rule_14->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_14->expressions);
rule_14->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_14->expressions);
rule_14->expressions->info = IFexpression;
PushLinearLinkedList(&selection_statement->rules);
selection_statement->rules->info = rule_14;
Rule *rule_15 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_15->expressions);
        rule_15->semanticAction = NULL;
        rule_15->nonTerminal = expression_statement;
PushLinearLinkedList(&rule_15->expressions);
rule_15->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&expression_statement->rules);
expression_statement->rules->info = rule_15;
Rule *rule_16 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_16->expressions);
        rule_16->semanticAction = NULL;
        rule_16->nonTerminal = expression_statement;
rule_16->semanticAction = semantic_16;
PushLinearLinkedList(&rule_16->expressions);
rule_16->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&rule_16->expressions);
rule_16->expressions->info = expressionexpression;
PushLinearLinkedList(&expression_statement->rules);
expression_statement->rules->info = rule_16;
Rule *rule_17 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_17->expressions);
        rule_17->semanticAction = NULL;
        rule_17->nonTerminal = statement_list;
rule_17->semanticAction = semantic_17;
PushLinearLinkedList(&rule_17->expressions);
rule_17->expressions->info = statementexpression;
PushLinearLinkedList(&statement_list->rules);
statement_list->rules->info = rule_17;
Rule *rule_18 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_18->expressions);
        rule_18->semanticAction = NULL;
        rule_18->nonTerminal = statement_list;
rule_18->semanticAction = semantic_18;
PushLinearLinkedList(&rule_18->expressions);
rule_18->expressions->info = statementexpression;
PushLinearLinkedList(&rule_18->expressions);
rule_18->expressions->info = statement_listexpression;
PushLinearLinkedList(&statement_list->rules);
statement_list->rules->info = rule_18;
Rule *rule_19 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_19->expressions);
        rule_19->semanticAction = NULL;
        rule_19->nonTerminal = declaration_list;
rule_19->semanticAction = semantic_19;
PushLinearLinkedList(&rule_19->expressions);
rule_19->expressions->info = declarationexpression;
PushLinearLinkedList(&declaration_list->rules);
declaration_list->rules->info = rule_19;
Rule *rule_20 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_20->expressions);
        rule_20->semanticAction = NULL;
        rule_20->nonTerminal = declaration_list;
rule_20->semanticAction = semantic_20;
PushLinearLinkedList(&rule_20->expressions);
rule_20->expressions->info = declarationexpression;
PushLinearLinkedList(&rule_20->expressions);
rule_20->expressions->info = declaration_listexpression;
PushLinearLinkedList(&declaration_list->rules);
declaration_list->rules->info = rule_20;
Rule *rule_21 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_21->expressions);
        rule_21->semanticAction = NULL;
        rule_21->nonTerminal = compound_statement;
PushLinearLinkedList(&rule_21->expressions);
rule_21->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_21->expressions);
rule_21->expressions->info = LEFT_CURLYexpression;
PushLinearLinkedList(&compound_statement->rules);
compound_statement->rules->info = rule_21;
Rule *rule_22 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_22->expressions);
        rule_22->semanticAction = NULL;
        rule_22->nonTerminal = compound_statement;
rule_22->semanticAction = semantic_22;
PushLinearLinkedList(&rule_22->expressions);
rule_22->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_22->expressions);
rule_22->expressions->info = statement_listexpression;
PushLinearLinkedList(&rule_22->expressions);
rule_22->expressions->info = block_enterexpression;
PushLinearLinkedList(&compound_statement->rules);
compound_statement->rules->info = rule_22;
Rule *rule_23 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_23->expressions);
        rule_23->semanticAction = NULL;
        rule_23->nonTerminal = compound_statement;
rule_23->semanticAction = semantic_23;
PushLinearLinkedList(&rule_23->expressions);
rule_23->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_23->expressions);
rule_23->expressions->info = declaration_listexpression;
PushLinearLinkedList(&rule_23->expressions);
rule_23->expressions->info = block_enterexpression;
PushLinearLinkedList(&compound_statement->rules);
compound_statement->rules->info = rule_23;
Rule *rule_24 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_24->expressions);
        rule_24->semanticAction = NULL;
        rule_24->nonTerminal = compound_statement;
rule_24->semanticAction = semantic_24;
PushLinearLinkedList(&rule_24->expressions);
rule_24->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_24->expressions);
rule_24->expressions->info = statement_listexpression;
PushLinearLinkedList(&rule_24->expressions);
rule_24->expressions->info = declaration_listexpression;
PushLinearLinkedList(&rule_24->expressions);
rule_24->expressions->info = block_enterexpression;
PushLinearLinkedList(&compound_statement->rules);
compound_statement->rules->info = rule_24;
Rule *rule_25 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_25->expressions);
        rule_25->semanticAction = NULL;
        rule_25->nonTerminal = block_enter;
rule_25->semanticAction = semantic_25;
PushLinearLinkedList(&rule_25->expressions);
rule_25->expressions->info = LEFT_CURLYexpression;
PushLinearLinkedList(&block_enter->rules);
block_enter->rules->info = rule_25;
Rule *rule_26 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_26->expressions);
        rule_26->semanticAction = NULL;
        rule_26->nonTerminal = statement;
PushLinearLinkedList(&rule_26->expressions);
rule_26->expressions->info = compound_statementexpression;
PushLinearLinkedList(&statement->rules);
statement->rules->info = rule_26;
Rule *rule_27 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_27->expressions);
        rule_27->semanticAction = NULL;
        rule_27->nonTerminal = statement;
PushLinearLinkedList(&rule_27->expressions);
rule_27->expressions->info = expression_statementexpression;
PushLinearLinkedList(&statement->rules);
statement->rules->info = rule_27;
Rule *rule_28 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_28->expressions);
        rule_28->semanticAction = NULL;
        rule_28->nonTerminal = statement;
PushLinearLinkedList(&rule_28->expressions);
rule_28->expressions->info = selection_statementexpression;
PushLinearLinkedList(&statement->rules);
statement->rules->info = rule_28;
Rule *rule_29 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_29->expressions);
        rule_29->semanticAction = NULL;
        rule_29->nonTerminal = statement;
PushLinearLinkedList(&rule_29->expressions);
rule_29->expressions->info = iteration_statementexpression;
PushLinearLinkedList(&statement->rules);
statement->rules->info = rule_29;
Rule *rule_30 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_30->expressions);
        rule_30->semanticAction = NULL;
        rule_30->nonTerminal = statement;
PushLinearLinkedList(&rule_30->expressions);
rule_30->expressions->info = jump_statementexpression;
PushLinearLinkedList(&statement->rules);
statement->rules->info = rule_30;
Rule *rule_31 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_31->expressions);
        rule_31->semanticAction = NULL;
        rule_31->nonTerminal = initializer_list;
PushLinearLinkedList(&rule_31->expressions);
rule_31->expressions->info = initializerexpression;
PushLinearLinkedList(&initializer_list->rules);
initializer_list->rules->info = rule_31;
Rule *rule_32 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_32->expressions);
        rule_32->semanticAction = NULL;
        rule_32->nonTerminal = initializer_list;
PushLinearLinkedList(&rule_32->expressions);
rule_32->expressions->info = initializerexpression;
PushLinearLinkedList(&rule_32->expressions);
rule_32->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_32->expressions);
rule_32->expressions->info = initializer_listexpression;
PushLinearLinkedList(&initializer_list->rules);
initializer_list->rules->info = rule_32;
Rule *rule_33 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_33->expressions);
        rule_33->semanticAction = NULL;
        rule_33->nonTerminal = initializer;
PushLinearLinkedList(&rule_33->expressions);
rule_33->expressions->info = assignment_expressionexpression;
PushLinearLinkedList(&initializer->rules);
initializer->rules->info = rule_33;
Rule *rule_34 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_34->expressions);
        rule_34->semanticAction = NULL;
        rule_34->nonTerminal = initializer;
PushLinearLinkedList(&rule_34->expressions);
rule_34->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_34->expressions);
rule_34->expressions->info = initializer_listexpression;
PushLinearLinkedList(&rule_34->expressions);
rule_34->expressions->info = LEFT_CURLYexpression;
PushLinearLinkedList(&initializer->rules);
initializer->rules->info = rule_34;
Rule *rule_35 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_35->expressions);
        rule_35->semanticAction = NULL;
        rule_35->nonTerminal = initializer;
PushLinearLinkedList(&rule_35->expressions);
rule_35->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_35->expressions);
rule_35->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_35->expressions);
rule_35->expressions->info = initializer_listexpression;
PushLinearLinkedList(&rule_35->expressions);
rule_35->expressions->info = LEFT_CURLYexpression;
PushLinearLinkedList(&initializer->rules);
initializer->rules->info = rule_35;
Rule *rule_36 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_36->expressions);
        rule_36->semanticAction = NULL;
        rule_36->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_36->expressions);
rule_36->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_36->expressions);
rule_36->expressions->info = abstract_declaratorexpression;
PushLinearLinkedList(&rule_36->expressions);
rule_36->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_36;
Rule *rule_37 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_37->expressions);
        rule_37->semanticAction = NULL;
        rule_37->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_37->expressions);
rule_37->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_37->expressions);
rule_37->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_37;
Rule *rule_38 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_38->expressions);
        rule_38->semanticAction = NULL;
        rule_38->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_38->expressions);
rule_38->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_38->expressions);
rule_38->expressions->info = constant_expressionexpression;
PushLinearLinkedList(&rule_38->expressions);
rule_38->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_38;
Rule *rule_39 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_39->expressions);
        rule_39->semanticAction = NULL;
        rule_39->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_39->expressions);
rule_39->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_39->expressions);
rule_39->expressions->info = constant_expressionexpression;
PushLinearLinkedList(&rule_39->expressions);
rule_39->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&rule_39->expressions);
rule_39->expressions->info = direct_abstract_declaratorexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_39;
Rule *rule_40 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_40->expressions);
        rule_40->semanticAction = NULL;
        rule_40->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_40->expressions);
rule_40->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_40->expressions);
rule_40->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&rule_40->expressions);
rule_40->expressions->info = direct_abstract_declaratorexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_40;
Rule *rule_41 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_41->expressions);
        rule_41->semanticAction = NULL;
        rule_41->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_41->expressions);
rule_41->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_41->expressions);
rule_41->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_41;
Rule *rule_42 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_42->expressions);
        rule_42->semanticAction = NULL;
        rule_42->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_42->expressions);
rule_42->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_42->expressions);
rule_42->expressions->info = parameter_type_listexpression;
PushLinearLinkedList(&rule_42->expressions);
rule_42->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_42;
Rule *rule_43 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_43->expressions);
        rule_43->semanticAction = NULL;
        rule_43->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_43->expressions);
rule_43->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_43->expressions);
rule_43->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_43->expressions);
rule_43->expressions->info = direct_abstract_declaratorexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_43;
Rule *rule_44 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_44->expressions);
        rule_44->semanticAction = NULL;
        rule_44->nonTerminal = direct_abstract_declarator;
PushLinearLinkedList(&rule_44->expressions);
rule_44->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_44->expressions);
rule_44->expressions->info = parameter_type_listexpression;
PushLinearLinkedList(&rule_44->expressions);
rule_44->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_44->expressions);
rule_44->expressions->info = direct_abstract_declaratorexpression;
PushLinearLinkedList(&direct_abstract_declarator->rules);
direct_abstract_declarator->rules->info = rule_44;
Rule *rule_45 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_45->expressions);
        rule_45->semanticAction = NULL;
        rule_45->nonTerminal = abstract_declarator;
PushLinearLinkedList(&rule_45->expressions);
rule_45->expressions->info = pointerexpression;
PushLinearLinkedList(&abstract_declarator->rules);
abstract_declarator->rules->info = rule_45;
Rule *rule_46 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_46->expressions);
        rule_46->semanticAction = NULL;
        rule_46->nonTerminal = abstract_declarator;
PushLinearLinkedList(&rule_46->expressions);
rule_46->expressions->info = direct_abstract_declaratorexpression;
PushLinearLinkedList(&abstract_declarator->rules);
abstract_declarator->rules->info = rule_46;
Rule *rule_47 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_47->expressions);
        rule_47->semanticAction = NULL;
        rule_47->nonTerminal = abstract_declarator;
PushLinearLinkedList(&rule_47->expressions);
rule_47->expressions->info = direct_abstract_declaratorexpression;
PushLinearLinkedList(&rule_47->expressions);
rule_47->expressions->info = pointerexpression;
PushLinearLinkedList(&abstract_declarator->rules);
abstract_declarator->rules->info = rule_47;
Rule *rule_48 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_48->expressions);
        rule_48->semanticAction = NULL;
        rule_48->nonTerminal = type_name;
PushLinearLinkedList(&rule_48->expressions);
rule_48->expressions->info = specifier_qualifier_listexpression;
PushLinearLinkedList(&type_name->rules);
type_name->rules->info = rule_48;
Rule *rule_49 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_49->expressions);
        rule_49->semanticAction = NULL;
        rule_49->nonTerminal = type_name;
PushLinearLinkedList(&rule_49->expressions);
rule_49->expressions->info = abstract_declaratorexpression;
PushLinearLinkedList(&rule_49->expressions);
rule_49->expressions->info = specifier_qualifier_listexpression;
PushLinearLinkedList(&type_name->rules);
type_name->rules->info = rule_49;
Rule *rule_50 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_50->expressions);
        rule_50->semanticAction = NULL;
        rule_50->nonTerminal = identifier_list;
PushLinearLinkedList(&rule_50->expressions);
rule_50->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&identifier_list->rules);
identifier_list->rules->info = rule_50;
Rule *rule_51 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_51->expressions);
        rule_51->semanticAction = NULL;
        rule_51->nonTerminal = identifier_list;
PushLinearLinkedList(&rule_51->expressions);
rule_51->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&rule_51->expressions);
rule_51->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_51->expressions);
rule_51->expressions->info = identifier_listexpression;
PushLinearLinkedList(&identifier_list->rules);
identifier_list->rules->info = rule_51;
Rule *rule_52 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_52->expressions);
        rule_52->semanticAction = NULL;
        rule_52->nonTerminal = parameter_declaration;
rule_52->semanticAction = semantic_52;
PushLinearLinkedList(&rule_52->expressions);
rule_52->expressions->info = declaratorexpression;
PushLinearLinkedList(&rule_52->expressions);
rule_52->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&parameter_declaration->rules);
parameter_declaration->rules->info = rule_52;
Rule *rule_53 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_53->expressions);
        rule_53->semanticAction = NULL;
        rule_53->nonTerminal = parameter_declaration;
PushLinearLinkedList(&rule_53->expressions);
rule_53->expressions->info = abstract_declaratorexpression;
PushLinearLinkedList(&rule_53->expressions);
rule_53->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&parameter_declaration->rules);
parameter_declaration->rules->info = rule_53;
Rule *rule_54 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_54->expressions);
        rule_54->semanticAction = NULL;
        rule_54->nonTerminal = parameter_declaration;
PushLinearLinkedList(&rule_54->expressions);
rule_54->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&parameter_declaration->rules);
parameter_declaration->rules->info = rule_54;
Rule *rule_55 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_55->expressions);
        rule_55->semanticAction = NULL;
        rule_55->nonTerminal = parameter_list;
PushLinearLinkedList(&rule_55->expressions);
rule_55->expressions->info = parameter_declarationexpression;
PushLinearLinkedList(&parameter_list->rules);
parameter_list->rules->info = rule_55;
Rule *rule_56 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_56->expressions);
        rule_56->semanticAction = NULL;
        rule_56->nonTerminal = parameter_list;
PushLinearLinkedList(&rule_56->expressions);
rule_56->expressions->info = parameter_declarationexpression;
PushLinearLinkedList(&rule_56->expressions);
rule_56->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_56->expressions);
rule_56->expressions->info = parameter_listexpression;
PushLinearLinkedList(&parameter_list->rules);
parameter_list->rules->info = rule_56;
Rule *rule_57 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_57->expressions);
        rule_57->semanticAction = NULL;
        rule_57->nonTerminal = parameter_type_list;
PushLinearLinkedList(&rule_57->expressions);
rule_57->expressions->info = parameter_listexpression;
PushLinearLinkedList(&parameter_type_list->rules);
parameter_type_list->rules->info = rule_57;
Rule *rule_58 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_58->expressions);
        rule_58->semanticAction = NULL;
        rule_58->nonTerminal = pointer;
PushLinearLinkedList(&rule_58->expressions);
rule_58->expressions->info = STARexpression;
PushLinearLinkedList(&pointer->rules);
pointer->rules->info = rule_58;
Rule *rule_59 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_59->expressions);
        rule_59->semanticAction = NULL;
        rule_59->nonTerminal = pointer;
PushLinearLinkedList(&rule_59->expressions);
rule_59->expressions->info = pointerexpression;
PushLinearLinkedList(&rule_59->expressions);
rule_59->expressions->info = STARexpression;
PushLinearLinkedList(&pointer->rules);
pointer->rules->info = rule_59;
Rule *rule_60 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_60->expressions);
        rule_60->semanticAction = NULL;
        rule_60->nonTerminal = direct_declarator;
rule_60->semanticAction = semantic_60;
PushLinearLinkedList(&rule_60->expressions);
rule_60->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&direct_declarator->rules);
direct_declarator->rules->info = rule_60;
Rule *rule_61 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_61->expressions);
        rule_61->semanticAction = NULL;
        rule_61->nonTerminal = direct_declarator;
PushLinearLinkedList(&rule_61->expressions);
rule_61->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_61->expressions);
rule_61->expressions->info = constant_expressionexpression;
PushLinearLinkedList(&rule_61->expressions);
rule_61->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&direct_declarator->rules);
direct_declarator->rules->info = rule_61;
Rule *rule_62 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_62->expressions);
        rule_62->semanticAction = NULL;
        rule_62->nonTerminal = direct_declarator;
PushLinearLinkedList(&rule_62->expressions);
rule_62->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_62->expressions);
rule_62->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&direct_declarator->rules);
direct_declarator->rules->info = rule_62;
Rule *rule_63 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_63->expressions);
        rule_63->semanticAction = NULL;
        rule_63->nonTerminal = direct_declarator;
PushLinearLinkedList(&rule_63->expressions);
rule_63->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_63->expressions);
rule_63->expressions->info = parameter_type_listexpression;
PushLinearLinkedList(&rule_63->expressions);
rule_63->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&direct_declarator->rules);
direct_declarator->rules->info = rule_63;
Rule *rule_64 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_64->expressions);
        rule_64->semanticAction = NULL;
        rule_64->nonTerminal = direct_declarator;
PushLinearLinkedList(&rule_64->expressions);
rule_64->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_64->expressions);
rule_64->expressions->info = identifier_listexpression;
PushLinearLinkedList(&rule_64->expressions);
rule_64->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&direct_declarator->rules);
direct_declarator->rules->info = rule_64;
Rule *rule_65 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_65->expressions);
        rule_65->semanticAction = NULL;
        rule_65->nonTerminal = declarator;
PushLinearLinkedList(&rule_65->expressions);
rule_65->expressions->info = direct_declaratorexpression;
PushLinearLinkedList(&rule_65->expressions);
rule_65->expressions->info = pointerexpression;
PushLinearLinkedList(&declarator->rules);
declarator->rules->info = rule_65;
Rule *rule_66 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_66->expressions);
        rule_66->semanticAction = NULL;
        rule_66->nonTerminal = declarator;
PushLinearLinkedList(&rule_66->expressions);
rule_66->expressions->info = direct_declaratorexpression;
PushLinearLinkedList(&declarator->rules);
declarator->rules->info = rule_66;
Rule *rule_67 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_67->expressions);
        rule_67->semanticAction = NULL;
        rule_67->nonTerminal = enumerator;
PushLinearLinkedList(&rule_67->expressions);
rule_67->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&enumerator->rules);
enumerator->rules->info = rule_67;
Rule *rule_68 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_68->expressions);
        rule_68->semanticAction = NULL;
        rule_68->nonTerminal = enumerator;
PushLinearLinkedList(&rule_68->expressions);
rule_68->expressions->info = constant_expressionexpression;
PushLinearLinkedList(&rule_68->expressions);
rule_68->expressions->info = EQexpression;
PushLinearLinkedList(&rule_68->expressions);
rule_68->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&enumerator->rules);
enumerator->rules->info = rule_68;
Rule *rule_69 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_69->expressions);
        rule_69->semanticAction = NULL;
        rule_69->nonTerminal = enumerator_list;
PushLinearLinkedList(&rule_69->expressions);
rule_69->expressions->info = enumeratorexpression;
PushLinearLinkedList(&enumerator_list->rules);
enumerator_list->rules->info = rule_69;
Rule *rule_70 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_70->expressions);
        rule_70->semanticAction = NULL;
        rule_70->nonTerminal = enumerator_list;
PushLinearLinkedList(&rule_70->expressions);
rule_70->expressions->info = enumeratorexpression;
PushLinearLinkedList(&rule_70->expressions);
rule_70->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_70->expressions);
rule_70->expressions->info = enumerator_listexpression;
PushLinearLinkedList(&enumerator_list->rules);
enumerator_list->rules->info = rule_70;
Rule *rule_71 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_71->expressions);
        rule_71->semanticAction = NULL;
        rule_71->nonTerminal = struct_declarator;
PushLinearLinkedList(&rule_71->expressions);
rule_71->expressions->info = declaratorexpression;
PushLinearLinkedList(&struct_declarator->rules);
struct_declarator->rules->info = rule_71;
Rule *rule_72 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_72->expressions);
        rule_72->semanticAction = NULL;
        rule_72->nonTerminal = struct_declarator_list;
PushLinearLinkedList(&rule_72->expressions);
rule_72->expressions->info = struct_declaratorexpression;
PushLinearLinkedList(&struct_declarator_list->rules);
struct_declarator_list->rules->info = rule_72;
Rule *rule_73 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_73->expressions);
        rule_73->semanticAction = NULL;
        rule_73->nonTerminal = struct_declarator_list;
PushLinearLinkedList(&rule_73->expressions);
rule_73->expressions->info = struct_declaratorexpression;
PushLinearLinkedList(&rule_73->expressions);
rule_73->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_73->expressions);
rule_73->expressions->info = struct_declarator_listexpression;
PushLinearLinkedList(&struct_declarator_list->rules);
struct_declarator_list->rules->info = rule_73;
Rule *rule_74 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_74->expressions);
        rule_74->semanticAction = NULL;
        rule_74->nonTerminal = specifier_qualifier_list;
PushLinearLinkedList(&rule_74->expressions);
rule_74->expressions->info = specifier_qualifier_listexpression;
PushLinearLinkedList(&rule_74->expressions);
rule_74->expressions->info = type_specifierexpression;
PushLinearLinkedList(&specifier_qualifier_list->rules);
specifier_qualifier_list->rules->info = rule_74;
Rule *rule_75 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_75->expressions);
        rule_75->semanticAction = NULL;
        rule_75->nonTerminal = specifier_qualifier_list;
PushLinearLinkedList(&rule_75->expressions);
rule_75->expressions->info = type_specifierexpression;
PushLinearLinkedList(&specifier_qualifier_list->rules);
specifier_qualifier_list->rules->info = rule_75;
Rule *rule_76 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_76->expressions);
        rule_76->semanticAction = NULL;
        rule_76->nonTerminal = struct_declaration;
PushLinearLinkedList(&rule_76->expressions);
rule_76->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&rule_76->expressions);
rule_76->expressions->info = struct_declarator_listexpression;
PushLinearLinkedList(&rule_76->expressions);
rule_76->expressions->info = specifier_qualifier_listexpression;
PushLinearLinkedList(&struct_declaration->rules);
struct_declaration->rules->info = rule_76;
Rule *rule_77 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_77->expressions);
        rule_77->semanticAction = NULL;
        rule_77->nonTerminal = struct_declaration_list;
PushLinearLinkedList(&rule_77->expressions);
rule_77->expressions->info = struct_declarationexpression;
PushLinearLinkedList(&struct_declaration_list->rules);
struct_declaration_list->rules->info = rule_77;
Rule *rule_78 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_78->expressions);
        rule_78->semanticAction = NULL;
        rule_78->nonTerminal = struct_declaration_list;
PushLinearLinkedList(&rule_78->expressions);
rule_78->expressions->info = struct_declarationexpression;
PushLinearLinkedList(&rule_78->expressions);
rule_78->expressions->info = struct_declaration_listexpression;
PushLinearLinkedList(&struct_declaration_list->rules);
struct_declaration_list->rules->info = rule_78;
Rule *rule_79 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_79->expressions);
        rule_79->semanticAction = NULL;
        rule_79->nonTerminal = struct_or_union_specifier;
PushLinearLinkedList(&rule_79->expressions);
rule_79->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_79->expressions);
rule_79->expressions->info = struct_declaration_listexpression;
PushLinearLinkedList(&rule_79->expressions);
rule_79->expressions->info = LEFT_CURLYexpression;
PushLinearLinkedList(&rule_79->expressions);
rule_79->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&rule_79->expressions);
rule_79->expressions->info = STRUCTexpression;
PushLinearLinkedList(&struct_or_union_specifier->rules);
struct_or_union_specifier->rules->info = rule_79;
Rule *rule_80 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_80->expressions);
        rule_80->semanticAction = NULL;
        rule_80->nonTerminal = struct_or_union_specifier;
PushLinearLinkedList(&rule_80->expressions);
rule_80->expressions->info = RIGHT_CURLYexpression;
PushLinearLinkedList(&rule_80->expressions);
rule_80->expressions->info = struct_declaration_listexpression;
PushLinearLinkedList(&rule_80->expressions);
rule_80->expressions->info = LEFT_CURLYexpression;
PushLinearLinkedList(&rule_80->expressions);
rule_80->expressions->info = STRUCTexpression;
PushLinearLinkedList(&struct_or_union_specifier->rules);
struct_or_union_specifier->rules->info = rule_80;
Rule *rule_81 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_81->expressions);
        rule_81->semanticAction = NULL;
        rule_81->nonTerminal = struct_or_union_specifier;
PushLinearLinkedList(&rule_81->expressions);
rule_81->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&rule_81->expressions);
rule_81->expressions->info = STRUCTexpression;
PushLinearLinkedList(&struct_or_union_specifier->rules);
struct_or_union_specifier->rules->info = rule_81;
Rule *rule_82 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_82->expressions);
        rule_82->semanticAction = NULL;
        rule_82->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_82->expressions);
rule_82->expressions->info = VOIDexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_82;
Rule *rule_83 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_83->expressions);
        rule_83->semanticAction = NULL;
        rule_83->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_83->expressions);
rule_83->expressions->info = CHARexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_83;
Rule *rule_84 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_84->expressions);
        rule_84->semanticAction = NULL;
        rule_84->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_84->expressions);
rule_84->expressions->info = SHORTexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_84;
Rule *rule_85 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_85->expressions);
        rule_85->semanticAction = NULL;
        rule_85->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_85->expressions);
rule_85->expressions->info = INTexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_85;
Rule *rule_86 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_86->expressions);
        rule_86->semanticAction = NULL;
        rule_86->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_86->expressions);
rule_86->expressions->info = LONGexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_86;
Rule *rule_87 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_87->expressions);
        rule_87->semanticAction = NULL;
        rule_87->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_87->expressions);
rule_87->expressions->info = FLOATexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_87;
Rule *rule_88 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_88->expressions);
        rule_88->semanticAction = NULL;
        rule_88->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_88->expressions);
rule_88->expressions->info = DOUBLEexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_88;
Rule *rule_89 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_89->expressions);
        rule_89->semanticAction = NULL;
        rule_89->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_89->expressions);
rule_89->expressions->info = UNSIGNEDexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_89;
Rule *rule_90 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_90->expressions);
        rule_90->semanticAction = NULL;
        rule_90->nonTerminal = type_specifier;
PushLinearLinkedList(&rule_90->expressions);
rule_90->expressions->info = struct_or_union_specifierexpression;
PushLinearLinkedList(&type_specifier->rules);
type_specifier->rules->info = rule_90;
Rule *rule_91 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_91->expressions);
        rule_91->semanticAction = NULL;
        rule_91->nonTerminal = init_declarator;
PushLinearLinkedList(&rule_91->expressions);
rule_91->expressions->info = declaratorexpression;
PushLinearLinkedList(&init_declarator->rules);
init_declarator->rules->info = rule_91;
Rule *rule_92 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_92->expressions);
        rule_92->semanticAction = NULL;
        rule_92->nonTerminal = init_declarator;
PushLinearLinkedList(&rule_92->expressions);
rule_92->expressions->info = initializerexpression;
PushLinearLinkedList(&rule_92->expressions);
rule_92->expressions->info = EQexpression;
PushLinearLinkedList(&rule_92->expressions);
rule_92->expressions->info = declaratorexpression;
PushLinearLinkedList(&init_declarator->rules);
init_declarator->rules->info = rule_92;
Rule *rule_93 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_93->expressions);
        rule_93->semanticAction = NULL;
        rule_93->nonTerminal = init_declarator_list;
PushLinearLinkedList(&rule_93->expressions);
rule_93->expressions->info = init_declaratorexpression;
PushLinearLinkedList(&init_declarator_list->rules);
init_declarator_list->rules->info = rule_93;
Rule *rule_94 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_94->expressions);
        rule_94->semanticAction = NULL;
        rule_94->nonTerminal = init_declarator_list;
PushLinearLinkedList(&rule_94->expressions);
rule_94->expressions->info = init_declaratorexpression;
PushLinearLinkedList(&rule_94->expressions);
rule_94->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_94->expressions);
rule_94->expressions->info = init_declarator_listexpression;
PushLinearLinkedList(&init_declarator_list->rules);
init_declarator_list->rules->info = rule_94;
Rule *rule_95 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_95->expressions);
        rule_95->semanticAction = NULL;
        rule_95->nonTerminal = declaration_specifiers;
PushLinearLinkedList(&rule_95->expressions);
rule_95->expressions->info = type_specifierexpression;
PushLinearLinkedList(&declaration_specifiers->rules);
declaration_specifiers->rules->info = rule_95;
Rule *rule_96 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_96->expressions);
        rule_96->semanticAction = NULL;
        rule_96->nonTerminal = declaration_specifiers;
PushLinearLinkedList(&rule_96->expressions);
rule_96->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&rule_96->expressions);
rule_96->expressions->info = type_specifierexpression;
PushLinearLinkedList(&declaration_specifiers->rules);
declaration_specifiers->rules->info = rule_96;
Rule *rule_97 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_97->expressions);
        rule_97->semanticAction = NULL;
        rule_97->nonTerminal = declaration;
PushLinearLinkedList(&rule_97->expressions);
rule_97->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&rule_97->expressions);
rule_97->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&declaration->rules);
declaration->rules->info = rule_97;
Rule *rule_98 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_98->expressions);
        rule_98->semanticAction = NULL;
        rule_98->nonTerminal = declaration;
rule_98->semanticAction = semantic_98;
PushLinearLinkedList(&rule_98->expressions);
rule_98->expressions->info = SEMI_COLONexpression;
PushLinearLinkedList(&rule_98->expressions);
rule_98->expressions->info = init_declarator_listexpression;
PushLinearLinkedList(&rule_98->expressions);
rule_98->expressions->info = declaration_specifiersexpression;
PushLinearLinkedList(&declaration->rules);
declaration->rules->info = rule_98;
Rule *rule_99 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_99->expressions);
        rule_99->semanticAction = NULL;
        rule_99->nonTerminal = constant_expression;
PushLinearLinkedList(&rule_99->expressions);
rule_99->expressions->info = conditional_expressionexpression;
PushLinearLinkedList(&constant_expression->rules);
constant_expression->rules->info = rule_99;
Rule *rule_100 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_100->expressions);
        rule_100->semanticAction = NULL;
        rule_100->nonTerminal = expression;
PushLinearLinkedList(&rule_100->expressions);
rule_100->expressions->info = assignment_expressionexpression;
PushLinearLinkedList(&expression->rules);
expression->rules->info = rule_100;
Rule *rule_101 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_101->expressions);
        rule_101->semanticAction = NULL;
        rule_101->nonTerminal = expression;
PushLinearLinkedList(&rule_101->expressions);
rule_101->expressions->info = assignment_expressionexpression;
PushLinearLinkedList(&rule_101->expressions);
rule_101->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_101->expressions);
rule_101->expressions->info = expressionexpression;
PushLinearLinkedList(&expression->rules);
expression->rules->info = rule_101;
Rule *rule_102 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_102->expressions);
        rule_102->semanticAction = NULL;
        rule_102->nonTerminal = assignment_operator;
PushLinearLinkedList(&rule_102->expressions);
rule_102->expressions->info = EQexpression;
PushLinearLinkedList(&assignment_operator->rules);
assignment_operator->rules->info = rule_102;
Rule *rule_103 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_103->expressions);
        rule_103->semanticAction = NULL;
        rule_103->nonTerminal = assignment_operator;
PushLinearLinkedList(&rule_103->expressions);
rule_103->expressions->info = STAR_EQexpression;
PushLinearLinkedList(&assignment_operator->rules);
assignment_operator->rules->info = rule_103;
Rule *rule_104 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_104->expressions);
        rule_104->semanticAction = NULL;
        rule_104->nonTerminal = assignment_operator;
PushLinearLinkedList(&rule_104->expressions);
rule_104->expressions->info = SLASH_EQexpression;
PushLinearLinkedList(&assignment_operator->rules);
assignment_operator->rules->info = rule_104;
Rule *rule_105 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_105->expressions);
        rule_105->semanticAction = NULL;
        rule_105->nonTerminal = assignment_operator;
PushLinearLinkedList(&rule_105->expressions);
rule_105->expressions->info = MOD_EQexpression;
PushLinearLinkedList(&assignment_operator->rules);
assignment_operator->rules->info = rule_105;
Rule *rule_106 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_106->expressions);
        rule_106->semanticAction = NULL;
        rule_106->nonTerminal = assignment_operator;
PushLinearLinkedList(&rule_106->expressions);
rule_106->expressions->info = PLUS_EQexpression;
PushLinearLinkedList(&assignment_operator->rules);
assignment_operator->rules->info = rule_106;
Rule *rule_107 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_107->expressions);
        rule_107->semanticAction = NULL;
        rule_107->nonTerminal = assignment_operator;
PushLinearLinkedList(&rule_107->expressions);
rule_107->expressions->info = MINUS_EQexpression;
PushLinearLinkedList(&assignment_operator->rules);
assignment_operator->rules->info = rule_107;
Rule *rule_108 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_108->expressions);
        rule_108->semanticAction = NULL;
        rule_108->nonTerminal = assignment_expression;
PushLinearLinkedList(&rule_108->expressions);
rule_108->expressions->info = conditional_expressionexpression;
PushLinearLinkedList(&assignment_expression->rules);
assignment_expression->rules->info = rule_108;
Rule *rule_109 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_109->expressions);
        rule_109->semanticAction = NULL;
        rule_109->nonTerminal = assignment_expression;
PushLinearLinkedList(&rule_109->expressions);
rule_109->expressions->info = assignment_expressionexpression;
PushLinearLinkedList(&rule_109->expressions);
rule_109->expressions->info = assignment_operatorexpression;
PushLinearLinkedList(&rule_109->expressions);
rule_109->expressions->info = unary_expressionexpression;
PushLinearLinkedList(&assignment_expression->rules);
assignment_expression->rules->info = rule_109;
Rule *rule_110 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_110->expressions);
        rule_110->semanticAction = NULL;
        rule_110->nonTerminal = conditional_expression;
PushLinearLinkedList(&rule_110->expressions);
rule_110->expressions->info = equality_expressionexpression;
PushLinearLinkedList(&conditional_expression->rules);
conditional_expression->rules->info = rule_110;
Rule *rule_111 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_111->expressions);
        rule_111->semanticAction = NULL;
        rule_111->nonTerminal = equality_expression;
PushLinearLinkedList(&rule_111->expressions);
rule_111->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&equality_expression->rules);
equality_expression->rules->info = rule_111;
Rule *rule_112 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_112->expressions);
        rule_112->semanticAction = NULL;
        rule_112->nonTerminal = equality_expression;
PushLinearLinkedList(&rule_112->expressions);
rule_112->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&rule_112->expressions);
rule_112->expressions->info = EEQexpression;
PushLinearLinkedList(&rule_112->expressions);
rule_112->expressions->info = equality_expressionexpression;
PushLinearLinkedList(&equality_expression->rules);
equality_expression->rules->info = rule_112;
Rule *rule_113 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_113->expressions);
        rule_113->semanticAction = NULL;
        rule_113->nonTerminal = equality_expression;
PushLinearLinkedList(&rule_113->expressions);
rule_113->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&rule_113->expressions);
rule_113->expressions->info = NEQexpression;
PushLinearLinkedList(&rule_113->expressions);
rule_113->expressions->info = equality_expressionexpression;
PushLinearLinkedList(&equality_expression->rules);
equality_expression->rules->info = rule_113;
Rule *rule_114 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_114->expressions);
        rule_114->semanticAction = NULL;
        rule_114->nonTerminal = relational_expression;
PushLinearLinkedList(&rule_114->expressions);
rule_114->expressions->info = shift_expressionexpression;
PushLinearLinkedList(&relational_expression->rules);
relational_expression->rules->info = rule_114;
Rule *rule_115 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_115->expressions);
        rule_115->semanticAction = NULL;
        rule_115->nonTerminal = relational_expression;
PushLinearLinkedList(&rule_115->expressions);
rule_115->expressions->info = shift_expressionexpression;
PushLinearLinkedList(&rule_115->expressions);
rule_115->expressions->info = GTexpression;
PushLinearLinkedList(&rule_115->expressions);
rule_115->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&relational_expression->rules);
relational_expression->rules->info = rule_115;
Rule *rule_116 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_116->expressions);
        rule_116->semanticAction = NULL;
        rule_116->nonTerminal = relational_expression;
PushLinearLinkedList(&rule_116->expressions);
rule_116->expressions->info = shift_expressionexpression;
PushLinearLinkedList(&rule_116->expressions);
rule_116->expressions->info = LTexpression;
PushLinearLinkedList(&rule_116->expressions);
rule_116->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&relational_expression->rules);
relational_expression->rules->info = rule_116;
Rule *rule_117 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_117->expressions);
        rule_117->semanticAction = NULL;
        rule_117->nonTerminal = relational_expression;
PushLinearLinkedList(&rule_117->expressions);
rule_117->expressions->info = shift_expressionexpression;
PushLinearLinkedList(&rule_117->expressions);
rule_117->expressions->info = GEexpression;
PushLinearLinkedList(&rule_117->expressions);
rule_117->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&relational_expression->rules);
relational_expression->rules->info = rule_117;
Rule *rule_118 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_118->expressions);
        rule_118->semanticAction = NULL;
        rule_118->nonTerminal = relational_expression;
PushLinearLinkedList(&rule_118->expressions);
rule_118->expressions->info = shift_expressionexpression;
PushLinearLinkedList(&rule_118->expressions);
rule_118->expressions->info = LEexpression;
PushLinearLinkedList(&rule_118->expressions);
rule_118->expressions->info = relational_expressionexpression;
PushLinearLinkedList(&relational_expression->rules);
relational_expression->rules->info = rule_118;
Rule *rule_119 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_119->expressions);
        rule_119->semanticAction = NULL;
        rule_119->nonTerminal = shift_expression;
PushLinearLinkedList(&rule_119->expressions);
rule_119->expressions->info = additive_expressionexpression;
PushLinearLinkedList(&shift_expression->rules);
shift_expression->rules->info = rule_119;
Rule *rule_120 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_120->expressions);
        rule_120->semanticAction = NULL;
        rule_120->nonTerminal = additive_expression;
PushLinearLinkedList(&rule_120->expressions);
rule_120->expressions->info = multiplicative_expressionexpression;
PushLinearLinkedList(&additive_expression->rules);
additive_expression->rules->info = rule_120;
Rule *rule_121 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_121->expressions);
        rule_121->semanticAction = NULL;
        rule_121->nonTerminal = additive_expression;
rule_121->semanticAction = semantic_121;
PushLinearLinkedList(&rule_121->expressions);
rule_121->expressions->info = multiplicative_expressionexpression;
PushLinearLinkedList(&rule_121->expressions);
rule_121->expressions->info = PLUSexpression;
PushLinearLinkedList(&rule_121->expressions);
rule_121->expressions->info = additive_expressionexpression;
PushLinearLinkedList(&additive_expression->rules);
additive_expression->rules->info = rule_121;
Rule *rule_122 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_122->expressions);
        rule_122->semanticAction = NULL;
        rule_122->nonTerminal = additive_expression;
PushLinearLinkedList(&rule_122->expressions);
rule_122->expressions->info = multiplicative_expressionexpression;
PushLinearLinkedList(&rule_122->expressions);
rule_122->expressions->info = MINUSexpression;
PushLinearLinkedList(&rule_122->expressions);
rule_122->expressions->info = additive_expressionexpression;
PushLinearLinkedList(&additive_expression->rules);
additive_expression->rules->info = rule_122;
Rule *rule_123 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_123->expressions);
        rule_123->semanticAction = NULL;
        rule_123->nonTerminal = multiplicative_expression;
PushLinearLinkedList(&rule_123->expressions);
rule_123->expressions->info = cast_expressionexpression;
PushLinearLinkedList(&multiplicative_expression->rules);
multiplicative_expression->rules->info = rule_123;
Rule *rule_124 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_124->expressions);
        rule_124->semanticAction = NULL;
        rule_124->nonTerminal = multiplicative_expression;
PushLinearLinkedList(&rule_124->expressions);
rule_124->expressions->info = cast_expressionexpression;
PushLinearLinkedList(&rule_124->expressions);
rule_124->expressions->info = STARexpression;
PushLinearLinkedList(&rule_124->expressions);
rule_124->expressions->info = multiplicative_expressionexpression;
PushLinearLinkedList(&multiplicative_expression->rules);
multiplicative_expression->rules->info = rule_124;
Rule *rule_125 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_125->expressions);
        rule_125->semanticAction = NULL;
        rule_125->nonTerminal = multiplicative_expression;
PushLinearLinkedList(&rule_125->expressions);
rule_125->expressions->info = cast_expressionexpression;
PushLinearLinkedList(&rule_125->expressions);
rule_125->expressions->info = SLASHexpression;
PushLinearLinkedList(&rule_125->expressions);
rule_125->expressions->info = multiplicative_expressionexpression;
PushLinearLinkedList(&multiplicative_expression->rules);
multiplicative_expression->rules->info = rule_125;
Rule *rule_126 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_126->expressions);
        rule_126->semanticAction = NULL;
        rule_126->nonTerminal = multiplicative_expression;
PushLinearLinkedList(&rule_126->expressions);
rule_126->expressions->info = cast_expressionexpression;
PushLinearLinkedList(&rule_126->expressions);
rule_126->expressions->info = MODexpression;
PushLinearLinkedList(&rule_126->expressions);
rule_126->expressions->info = multiplicative_expressionexpression;
PushLinearLinkedList(&multiplicative_expression->rules);
multiplicative_expression->rules->info = rule_126;
Rule *rule_127 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_127->expressions);
        rule_127->semanticAction = NULL;
        rule_127->nonTerminal = cast_expression;
PushLinearLinkedList(&rule_127->expressions);
rule_127->expressions->info = unary_expressionexpression;
PushLinearLinkedList(&cast_expression->rules);
cast_expression->rules->info = rule_127;
Rule *rule_128 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_128->expressions);
        rule_128->semanticAction = NULL;
        rule_128->nonTerminal = cast_expression;
PushLinearLinkedList(&rule_128->expressions);
rule_128->expressions->info = cast_expressionexpression;
PushLinearLinkedList(&rule_128->expressions);
rule_128->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_128->expressions);
rule_128->expressions->info = type_nameexpression;
PushLinearLinkedList(&rule_128->expressions);
rule_128->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&cast_expression->rules);
cast_expression->rules->info = rule_128;
Rule *rule_129 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_129->expressions);
        rule_129->semanticAction = NULL;
        rule_129->nonTerminal = unary_operator;
PushLinearLinkedList(&rule_129->expressions);
rule_129->expressions->info = STARexpression;
PushLinearLinkedList(&unary_operator->rules);
unary_operator->rules->info = rule_129;
Rule *rule_130 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_130->expressions);
        rule_130->semanticAction = NULL;
        rule_130->nonTerminal = unary_operator;
PushLinearLinkedList(&rule_130->expressions);
rule_130->expressions->info = PLUSexpression;
PushLinearLinkedList(&unary_operator->rules);
unary_operator->rules->info = rule_130;
Rule *rule_131 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_131->expressions);
        rule_131->semanticAction = NULL;
        rule_131->nonTerminal = unary_operator;
PushLinearLinkedList(&rule_131->expressions);
rule_131->expressions->info = MINUSexpression;
PushLinearLinkedList(&unary_operator->rules);
unary_operator->rules->info = rule_131;
Rule *rule_132 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_132->expressions);
        rule_132->semanticAction = NULL;
        rule_132->nonTerminal = unary_operator;
PushLinearLinkedList(&rule_132->expressions);
rule_132->expressions->info = AMPERSANDexpression;
PushLinearLinkedList(&unary_operator->rules);
unary_operator->rules->info = rule_132;
Rule *rule_133 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_133->expressions);
        rule_133->semanticAction = NULL;
        rule_133->nonTerminal = unary_expression;
PushLinearLinkedList(&rule_133->expressions);
rule_133->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&unary_expression->rules);
unary_expression->rules->info = rule_133;
Rule *rule_134 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_134->expressions);
        rule_134->semanticAction = NULL;
        rule_134->nonTerminal = unary_expression;
PushLinearLinkedList(&rule_134->expressions);
rule_134->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&rule_134->expressions);
rule_134->expressions->info = PLUS_PLUSexpression;
PushLinearLinkedList(&unary_expression->rules);
unary_expression->rules->info = rule_134;
Rule *rule_135 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_135->expressions);
        rule_135->semanticAction = NULL;
        rule_135->nonTerminal = unary_expression;
PushLinearLinkedList(&rule_135->expressions);
rule_135->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&rule_135->expressions);
rule_135->expressions->info = MINUS_MINUSexpression;
PushLinearLinkedList(&unary_expression->rules);
unary_expression->rules->info = rule_135;
Rule *rule_136 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_136->expressions);
        rule_136->semanticAction = NULL;
        rule_136->nonTerminal = unary_expression;
PushLinearLinkedList(&rule_136->expressions);
rule_136->expressions->info = cast_expressionexpression;
PushLinearLinkedList(&rule_136->expressions);
rule_136->expressions->info = unary_operatorexpression;
PushLinearLinkedList(&unary_expression->rules);
unary_expression->rules->info = rule_136;
Rule *rule_137 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_137->expressions);
        rule_137->semanticAction = NULL;
        rule_137->nonTerminal = argument_expression_list;
PushLinearLinkedList(&rule_137->expressions);
rule_137->expressions->info = assignment_expressionexpression;
PushLinearLinkedList(&argument_expression_list->rules);
argument_expression_list->rules->info = rule_137;
Rule *rule_138 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_138->expressions);
        rule_138->semanticAction = NULL;
        rule_138->nonTerminal = argument_expression_list;
PushLinearLinkedList(&rule_138->expressions);
rule_138->expressions->info = assignment_expressionexpression;
PushLinearLinkedList(&rule_138->expressions);
rule_138->expressions->info = COMMAexpression;
PushLinearLinkedList(&rule_138->expressions);
rule_138->expressions->info = argument_expression_listexpression;
PushLinearLinkedList(&argument_expression_list->rules);
argument_expression_list->rules->info = rule_138;
Rule *rule_139 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_139->expressions);
        rule_139->semanticAction = NULL;
        rule_139->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_139->expressions);
rule_139->expressions->info = primary_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_139;
Rule *rule_140 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_140->expressions);
        rule_140->semanticAction = NULL;
        rule_140->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_140->expressions);
rule_140->expressions->info = RIGHT_BRACKETexpression;
PushLinearLinkedList(&rule_140->expressions);
rule_140->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_140->expressions);
rule_140->expressions->info = LEFT_BRACKETexpression;
PushLinearLinkedList(&rule_140->expressions);
rule_140->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_140;
Rule *rule_141 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_141->expressions);
        rule_141->semanticAction = NULL;
        rule_141->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_141->expressions);
rule_141->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_141->expressions);
rule_141->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_141->expressions);
rule_141->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_141;
Rule *rule_142 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_142->expressions);
        rule_142->semanticAction = NULL;
        rule_142->nonTerminal = postfix_expression;
rule_142->semanticAction = semantic_142;
PushLinearLinkedList(&rule_142->expressions);
rule_142->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_142->expressions);
rule_142->expressions->info = argument_expression_listexpression;
PushLinearLinkedList(&rule_142->expressions);
rule_142->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&rule_142->expressions);
rule_142->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_142;
Rule *rule_143 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_143->expressions);
        rule_143->semanticAction = NULL;
        rule_143->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_143->expressions);
rule_143->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&rule_143->expressions);
rule_143->expressions->info = DOTexpression;
PushLinearLinkedList(&rule_143->expressions);
rule_143->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_143;
Rule *rule_144 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_144->expressions);
        rule_144->semanticAction = NULL;
        rule_144->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_144->expressions);
rule_144->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&rule_144->expressions);
rule_144->expressions->info = ARROWexpression;
PushLinearLinkedList(&rule_144->expressions);
rule_144->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_144;
Rule *rule_145 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_145->expressions);
        rule_145->semanticAction = NULL;
        rule_145->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_145->expressions);
rule_145->expressions->info = PLUS_PLUSexpression;
PushLinearLinkedList(&rule_145->expressions);
rule_145->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_145;
Rule *rule_146 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_146->expressions);
        rule_146->semanticAction = NULL;
        rule_146->nonTerminal = postfix_expression;
PushLinearLinkedList(&rule_146->expressions);
rule_146->expressions->info = MINUS_MINUSexpression;
PushLinearLinkedList(&rule_146->expressions);
rule_146->expressions->info = postfix_expressionexpression;
PushLinearLinkedList(&postfix_expression->rules);
postfix_expression->rules->info = rule_146;
Rule *rule_147 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_147->expressions);
        rule_147->semanticAction = NULL;
        rule_147->nonTerminal = primary_expression;
PushLinearLinkedList(&rule_147->expressions);
rule_147->expressions->info = IDENTIFIERexpression;
PushLinearLinkedList(&primary_expression->rules);
primary_expression->rules->info = rule_147;
Rule *rule_148 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_148->expressions);
        rule_148->semanticAction = NULL;
        rule_148->nonTerminal = primary_expression;
PushLinearLinkedList(&rule_148->expressions);
rule_148->expressions->info = INTEGER_LITERALexpression;
PushLinearLinkedList(&primary_expression->rules);
primary_expression->rules->info = rule_148;
Rule *rule_149 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_149->expressions);
        rule_149->semanticAction = NULL;
        rule_149->nonTerminal = primary_expression;
PushLinearLinkedList(&rule_149->expressions);
rule_149->expressions->info = FLOAT_LITERALexpression;
PushLinearLinkedList(&primary_expression->rules);
primary_expression->rules->info = rule_149;
Rule *rule_150 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_150->expressions);
        rule_150->semanticAction = NULL;
        rule_150->nonTerminal = primary_expression;
PushLinearLinkedList(&rule_150->expressions);
rule_150->expressions->info = STRING_LITERALexpression;
PushLinearLinkedList(&primary_expression->rules);
primary_expression->rules->info = rule_150;
Rule *rule_151 = malloc(sizeof(Rule));
        InitLinearLinkedList(&rule_151->expressions);
        rule_151->semanticAction = NULL;
        rule_151->nonTerminal = primary_expression;
PushLinearLinkedList(&rule_151->expressions);
rule_151->expressions->info = RIGHT_PARENexpression;
PushLinearLinkedList(&rule_151->expressions);
rule_151->expressions->info = expressionexpression;
PushLinearLinkedList(&rule_151->expressions);
rule_151->expressions->info = LEFT_PARENexpression;
PushLinearLinkedList(&primary_expression->rules);
primary_expression->rules->info = rule_151;
}